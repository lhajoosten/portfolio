{"version":3,"file":"index.mjs","names":["result: AnyObject","cachedDebugGroups: Set<string> | undefined","path","defaultExtensions: Extensions","defaultModuleEntryNames: ModuleEntryNames","simpleNameConflictResolver: NameConflictResolver","underscoreNameConflictResolver: NameConflictResolver","defaultNameConflictResolvers: NameConflictResolvers","event: LoggerEvent | undefined","event: LoggerEvent","result: StoredEventResult","ref","kindRank: Record<SymbolKind, number>","names: NameScopes","file","ctx: RenderContext","scope","sets: Array<Set<SymbolId>>","entries: Array<IndexEntry>","path","files: Array<IOutput>","path: Array<string>","cursor: StructureNode | undefined","path","path","cursor: StructureNode | null"],"sources":["../src/brands.ts","../src/config/interactive.ts","../src/config/merge.ts","../src/config/load.ts","../src/log.ts","../src/files/file.ts","../src/guards.ts","../src/languages/extensions.ts","../src/languages/modules.ts","../src/planner/resolvers.ts","../src/languages/resolvers.ts","../src/logger.ts","../src/files/registry.ts","../src/refs/refs.ts","../src/nodes/registry.ts","../src/project/namespace.ts","../src/planner/scope.ts","../src/planner/analyzer.ts","../src/planner/planner.ts","../src/symbols/symbol.ts","../src/symbols/registry.ts","../src/project/project.ts","../src/structure/node.ts","../src/structure/model.ts"],"sourcesContent":["export const fileBrand = 'heyapi.file';\nexport const nodeBrand = 'heyapi.node';\nexport const symbolBrand = 'heyapi.symbol';\n","/**\n * Detect if the current session is interactive based on TTY status and environment variables.\n * This is used as a fallback when the user doesn't explicitly set the interactive option.\n * @internal\n */\nexport function detectInteractiveSession(): boolean {\n  return Boolean(\n    process.stdin.isTTY &&\n    process.stdout.isTTY &&\n    !process.env.CI &&\n    !process.env.NO_INTERACTIVE &&\n    !process.env.NO_INTERACTION,\n  );\n}\n","import type { AnyObject } from '@hey-api/types';\n\nfunction isPlainObject(value: unknown): value is AnyObject {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nexport function mergeConfigs<T extends AnyObject>(\n  configA: T | undefined,\n  configB: T | undefined,\n): T {\n  const a = (configA || {}) as AnyObject;\n  const b = (configB || {}) as AnyObject;\n\n  const result: AnyObject = { ...a };\n\n  for (const key of Object.keys(b)) {\n    const valueA = a[key];\n    const valueB = b[key];\n\n    if (isPlainObject(valueA) && isPlainObject(valueB)) {\n      result[key] = mergeConfigs(valueA, valueB);\n    } else {\n      result[key] = valueB;\n    }\n  }\n\n  return result as T;\n}\n","import type { AnyObject, MaybeArray } from '@hey-api/types';\nimport { loadConfig } from 'c12';\n\nimport type { Logger } from '../logger';\nimport { mergeConfigs } from './merge';\n\nexport async function loadConfigFile<T extends AnyObject>({\n  configFile,\n  logger,\n  name,\n  userConfig,\n}: {\n  configFile: string | undefined;\n  logger: Logger;\n  name: string;\n  userConfig: T;\n}): Promise<{\n  configFile: string | undefined;\n  configs: ReadonlyArray<T>;\n  foundConfig: boolean;\n}> {\n  const eventC12 = logger.timeEvent('c12');\n  const { config: fileConfig, configFile: loadedConfigFile } = await loadConfig<MaybeArray<T>>({\n    configFile,\n    name,\n  });\n  eventC12.timeEnd();\n\n  const fileConfigs = fileConfig instanceof Array ? fileConfig : [fileConfig];\n  const mergedConfigs = fileConfigs.map((config) => mergeConfigs<T>(config, userConfig));\n  const foundConfig = fileConfigs.some((config) => Object.keys(config).length > 0);\n\n  return { configFile: loadedConfigFile, configs: mergedConfigs, foundConfig };\n}\n","import type { MaybeArray, MaybeFunc } from '@hey-api/types';\nimport colors from 'ansi-colors';\n// @ts-expect-error\nimport colorSupport from 'color-support';\n\ncolors.enabled = colorSupport().hasBasic;\n\nconst DEBUG_NAMESPACE = 'heyapi';\n\nconst NO_WARNINGS = /^(1|true|yes|on)$/i.test(process.env.HEYAPI_DISABLE_WARNINGS ?? '');\n\nconst DebugGroups = {\n  analyzer: colors.greenBright,\n  dsl: colors.cyanBright,\n  file: colors.yellowBright,\n  registry: colors.blueBright,\n  symbol: colors.magentaBright,\n} as const;\n\nconst WarnGroups = {\n  deprecated: colors.magentaBright,\n} as const;\n\nlet cachedDebugGroups: Set<string> | undefined;\nfunction getDebugGroups(): Set<string> {\n  if (cachedDebugGroups) return cachedDebugGroups;\n\n  const value = process.env.DEBUG;\n  cachedDebugGroups = new Set(value ? value.split(',').map((x) => x.trim().toLowerCase()) : []);\n\n  return cachedDebugGroups;\n}\n\n/**\n * Tracks which deprecations have been shown to avoid spam.\n */\nconst shownDeprecations = new Set<string>();\n\nfunction debug(message: string, group: keyof typeof DebugGroups) {\n  const groups = getDebugGroups();\n  if (\n    !(\n      groups.has('*') ||\n      groups.has(`${DEBUG_NAMESPACE}:*`) ||\n      groups.has(`${DEBUG_NAMESPACE}:${group}`) ||\n      groups.has(group)\n    )\n  ) {\n    return;\n  }\n\n  const color = DebugGroups[group] ?? colors.whiteBright;\n  const prefix = color(`${DEBUG_NAMESPACE}:${group}`);\n\n  console.debug(`${prefix} ${message}`);\n}\n\nfunction warn(message: string, group: keyof typeof WarnGroups) {\n  if (NO_WARNINGS) return;\n\n  const color = WarnGroups[group] ?? colors.yellowBright;\n\n  console.warn(color(`${message}`));\n}\n\nfunction warnDeprecated({\n  context,\n  field,\n  replacement,\n}: {\n  context?: string;\n  field: string;\n  replacement?: MaybeFunc<(field: string) => MaybeArray<string>>;\n}) {\n  const key = context\n    ? `${context}:${field}:${JSON.stringify(replacement)}`\n    : `${field}:${JSON.stringify(replacement)}`;\n\n  if (shownDeprecations.has(key)) return;\n  shownDeprecations.add(key);\n\n  let message = `\\`${field}\\` is deprecated.`;\n\n  if (replacement) {\n    const reps = typeof replacement === 'function' ? replacement(field) : replacement;\n    const repArray = reps instanceof Array ? reps : [reps];\n    const repString = repArray.map((r) => `\\`${r}\\``).join(' or ');\n    message += ` Use ${repString} instead.`;\n  }\n\n  const prefix = context ? `[${context}] ` : '';\n  warn(`${prefix}${message}`, 'deprecated');\n}\n\nexport const log = {\n  debug,\n  warn,\n  warnDeprecated,\n};\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport { fileBrand } from '../brands';\nimport type { Language } from '../languages/types';\nimport { log } from '../log';\nimport type { INode } from '../nodes/node';\nimport type { NameScopes } from '../planner/scope';\nimport type { IProject } from '../project/types';\nimport type { Renderer } from '../renderer';\nimport type { IFileIn } from './types';\n\nexport class File<Node extends INode = INode> {\n  /**\n   * Exports from this file.\n   */\n  private _exports: Array<ExportModule> = [];\n  /**\n   * File extension (e.g. `.ts`).\n   */\n  private _extension?: string;\n  /**\n   * Actual emitted file path, including extension and directories.\n   */\n  private _finalPath?: string;\n  /**\n   * Imports to this file.\n   */\n  private _imports: Array<ImportModule> = [];\n  /**\n   * Language of the file.\n   */\n  private _language?: Language;\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  private _logicalFilePath: string;\n  /**\n   * Base name of the file (without extension).\n   */\n  private _name?: string;\n  /**\n   * Syntax nodes contained in this file.\n   */\n  private _nodes: Array<Node> = [];\n  /**\n   * Renderer assigned to this file.\n   */\n  private _renderer?: Renderer;\n\n  /** Brand used for identifying files. */\n  readonly '~brand' = fileBrand;\n  /** All names defined in this file, including local scopes. */\n  allNames: NameScopes = new Map();\n  /** Whether this file is external to the project. */\n  external: boolean;\n  /** Unique identifier for the file. */\n  readonly id: number;\n  /** The project this file belongs to. */\n  readonly project: IProject;\n  /** Names declared at the top level of the file. */\n  topLevelNames: NameScopes = new Map();\n\n  constructor(input: IFileIn, id: number, project: IProject) {\n    this.external = input.external ?? false;\n    this.id = id;\n    if (input.language !== undefined) this._language = input.language;\n    this._logicalFilePath = input.logicalFilePath.split(path.sep).join('/');\n    if (input.name !== undefined) this._name = input.name;\n    this.project = project;\n  }\n\n  /**\n   * Exports from this file.\n   */\n  get exports(): ReadonlyArray<ExportModule> {\n    return [...this._exports];\n  }\n\n  /**\n   * Read-only accessor for the file extension.\n   */\n  get extension(): string | undefined {\n    if (this.external) return;\n    if (this._extension) return this._extension;\n    const language = this.language;\n    const extension = language ? this.project.extensions[language] : undefined;\n    if (extension && extension[0]) return extension[0];\n    return;\n  }\n\n  /**\n   * Read-only accessor for the final emitted path.\n   *\n   * If undefined, the file has not yet been assigned a final path\n   * or is external to the project and should not be emitted.\n   */\n  get finalPath(): string | undefined {\n    if (this._finalPath) return this._finalPath;\n    const dirs = this._logicalFilePath ? this._logicalFilePath.split('/').slice(0, -1) : [];\n    return [...dirs, `${this.name}${this.extension ?? ''}`].join('/');\n  }\n\n  /**\n   * Imports to this file.\n   */\n  get imports(): ReadonlyArray<ImportModule> {\n    return [...this._imports];\n  }\n\n  /**\n   * Language of the file; inferred from nodes or fallback if not set explicitly.\n   */\n  get language(): Language | undefined {\n    if (this._language) return this._language;\n    if (this._nodes[0]) return this._nodes[0].language;\n    return;\n  }\n\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  get logicalFilePath(): string {\n    return this._logicalFilePath;\n  }\n\n  /**\n   * Base name of the file (without extension).\n   *\n   * If no name was set explicitly, it is inferred from the logical file path.\n   */\n  get name(): string {\n    if (this._name) return this._name;\n    const name = this._logicalFilePath.split('/').pop();\n    if (name) return name;\n    const message = `File ${this.toString()} has no name`;\n    log.debug(message, 'file');\n    throw new Error(message);\n  }\n\n  /**\n   * Syntax nodes contained in this file.\n   */\n  get nodes(): ReadonlyArray<Node> {\n    return [...this._nodes];\n  }\n\n  /**\n   * Renderer assigned to this file.\n   */\n  get renderer(): Renderer | undefined {\n    return this._renderer;\n  }\n\n  /**\n   * Add an export group to the file.\n   */\n  addExport(group: ExportModule): void {\n    this._exports.push(group);\n  }\n\n  /**\n   * Add an import group to the file.\n   */\n  addImport(group: ImportModule): void {\n    this._imports.push(group);\n  }\n\n  /**\n   * Add a syntax node to the file.\n   */\n  addNode(node: Node): void {\n    this._nodes.push(node);\n    node.file = this;\n  }\n\n  /**\n   * Sets the file extension.\n   */\n  setExtension(extension: string): void {\n    this._extension = extension;\n  }\n\n  /**\n   * Sets the final emitted path of the file.\n   */\n  setFinalPath(path: string): void {\n    this._finalPath = path;\n  }\n\n  /**\n   * Sets the language of the file.\n   */\n  setLanguage(lang: Language): void {\n    this._language = lang;\n  }\n\n  /**\n   * Sets the name of the file.\n   */\n  setName(name: string): void {\n    this._name = name;\n  }\n\n  /**\n   * Sets the renderer assigned to this file.\n   */\n  setRenderer(renderer: Renderer): void {\n    this._renderer = renderer;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the file.\n   */\n  toString(): string {\n    return `[File ${this._logicalFilePath}#${this.id}]`;\n  }\n}\n","import { nodeBrand, symbolBrand } from './brands';\nimport type { INode } from './nodes/node';\nimport type { Ref } from './refs/types';\nimport type { Symbol } from './symbols/symbol';\n\nexport function isBrand(value: unknown, brand: string): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return (value as any)['~brand'] === brand;\n}\n\nexport function isNode(value: unknown): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return isBrand(value, nodeBrand);\n}\n\nexport function isNodeRef(value: Ref<unknown>): value is Ref<INode> {\n  return isBrand(value['~ref'], nodeBrand);\n}\n\nexport function isSymbol(value: unknown): value is Symbol {\n  return isBrand(value, symbolBrand);\n}\n\nexport function isSymbolRef(value: Ref<unknown>): value is Ref<Symbol> {\n  return isBrand(value['~ref'], symbolBrand);\n}\n","import type { Extensions } from './types';\n\nexport const defaultExtensions: Extensions = {\n  c: ['.c'],\n  'c#': ['.cs'],\n  'c++': ['.cpp', '.hpp'],\n  css: ['.css'],\n  dart: ['.dart'],\n  go: ['.go'],\n  haskell: ['.hs'],\n  html: ['.html'],\n  java: ['.java'],\n  javascript: ['.js', '.jsx'],\n  json: ['.json'],\n  kotlin: ['.kt'],\n  lua: ['.lua'],\n  markdown: ['.md'],\n  matlab: ['.m'],\n  perl: ['.pl'],\n  php: ['.php'],\n  python: ['.py'],\n  r: ['.r'],\n  ruby: ['.rb'],\n  rust: ['.rs'],\n  scala: ['.scala'],\n  shell: ['.sh'],\n  sql: ['.sql'],\n  swift: ['.swift'],\n  typescript: ['.ts', '.tsx'],\n  yaml: ['.yaml', '.yml'],\n};\n","import type { ModuleEntryNames } from './types';\n\nexport const defaultModuleEntryNames: ModuleEntryNames = {\n  javascript: 'index',\n  python: '__init__',\n  typescript: 'index',\n};\n","import type { NameConflictResolver } from './types';\n\nexport const simpleNameConflictResolver: NameConflictResolver = ({ attempt, baseName }) =>\n  attempt === 0 ? baseName : `${baseName}${attempt + 1}`;\n\nexport const underscoreNameConflictResolver: NameConflictResolver = ({ attempt, baseName }) =>\n  attempt === 0 ? baseName : `${baseName}_${attempt + 1}`;\n","import { underscoreNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolvers } from './types';\n\nexport const defaultNameConflictResolvers: NameConflictResolvers = {\n  php: underscoreNameConflictResolver,\n  python: underscoreNameConflictResolver,\n  ruby: underscoreNameConflictResolver,\n};\n","import colors from 'ansi-colors';\n\ninterface LoggerEvent {\n  end?: PerformanceMark;\n  events: Array<LoggerEvent>;\n  id: string; // unique internal key\n  name: string;\n  start: PerformanceMark;\n}\n\ninterface Severity {\n  color: colors.StyleFunction;\n  type: 'duration' | 'percentage';\n}\n\ninterface StoredEventResult {\n  position: ReadonlyArray<number>;\n}\n\nlet loggerCounter = 0;\nconst nameToId = (name: string) => `${name}-${loggerCounter++}`;\nconst idEnd = (id: string) => `${id}-end`;\nconst idLength = (id: string) => `${id}-length`;\nconst idStart = (id: string) => `${id}-start`;\n\nconst getSeverity = (duration: number, percentage: number): Severity | undefined => {\n  if (duration > 200) {\n    return {\n      color: colors.red,\n      type: 'duration',\n    };\n  }\n  if (percentage > 30) {\n    return {\n      color: colors.red,\n      type: 'percentage',\n    };\n  }\n  if (duration > 50) {\n    return {\n      color: colors.yellow,\n      type: 'duration',\n    };\n  }\n  if (percentage > 10) {\n    return {\n      color: colors.yellow,\n      type: 'percentage',\n    };\n  }\n  return;\n};\n\nexport class Logger {\n  private events: Array<LoggerEvent> = [];\n\n  private end(result: StoredEventResult): void {\n    let event: LoggerEvent | undefined;\n    let events = this.events;\n    for (const index of result.position) {\n      event = events[index];\n      if (event?.events) {\n        events = event.events;\n      }\n    }\n    if (event && !event.end) {\n      event.end = performance.mark(idEnd(event.id));\n    }\n  }\n\n  /**\n   * Recursively end all unended events in the event tree.\n   * This ensures all events have end marks before measuring.\n   */\n  private endAllEvents(events: Array<LoggerEvent>): void {\n    for (const event of events) {\n      if (!event.end) {\n        event.end = performance.mark(idEnd(event.id));\n      }\n      if (event.events.length > 0) {\n        this.endAllEvents(event.events);\n      }\n    }\n  }\n\n  report(print: boolean = true): PerformanceMeasure | undefined {\n    const firstEvent = this.events[0];\n    if (!firstEvent) return;\n\n    // Ensure all events are ended before reporting\n    this.endAllEvents(this.events);\n\n    const lastEvent = this.events[this.events.length - 1]!;\n    const name = 'root';\n    const id = nameToId(name);\n\n    try {\n      const measure = performance.measure(\n        idLength(id),\n        idStart(firstEvent.id),\n        idEnd(lastEvent.id),\n      );\n      if (print) {\n        this.reportEvent({\n          end: lastEvent.end,\n          events: this.events,\n          id,\n          indent: 0,\n          measure,\n          name,\n          start: firstEvent!.start,\n        });\n      }\n      return measure;\n    } catch {\n      // If measuring fails (e.g., marks don't exist), silently skip reporting\n      // to avoid crashing the application\n      return;\n    }\n  }\n\n  private reportEvent({\n    indent,\n    ...parent\n  }: LoggerEvent & {\n    indent: number;\n    measure: PerformanceMeasure;\n  }): void {\n    const color = !indent ? colors.cyan : colors.gray;\n    const lastIndex = parent.events.length - 1;\n\n    parent.events.forEach((event, index) => {\n      try {\n        const measure = performance.measure(idLength(event.id), idStart(event.id), idEnd(event.id));\n        const duration = Math.ceil(measure.duration * 100) / 100;\n        const percentage =\n          Math.ceil((measure.duration / parent.measure.duration) * 100 * 100) / 100;\n        const severity = indent ? getSeverity(duration, percentage) : undefined;\n\n        let durationLabel = `${duration.toFixed(2).padStart(8)}ms`;\n        if (severity?.type === 'duration') {\n          durationLabel = severity.color(durationLabel);\n        }\n\n        const branch = index === lastIndex ? '└─ ' : '├─ ';\n        const prefix = !indent ? '' : '│  '.repeat(indent - 1) + branch;\n        const maxLength = 38 - prefix.length;\n\n        const percentageBranch = !indent ? '' : '↳ ';\n        const percentagePrefix = indent ? ' '.repeat(indent - 1) + percentageBranch : '';\n        let percentageLabel = `${percentagePrefix}${percentage.toFixed(2)}%`;\n        if (severity?.type === 'percentage') {\n          percentageLabel = severity.color(percentageLabel);\n        }\n        const jobPrefix = colors.gray('[root] ');\n        console.log(\n          `${jobPrefix}${colors.gray(prefix)}${color(\n            `${event.name.padEnd(maxLength)} ${durationLabel} (${percentageLabel})`,\n          )}`,\n        );\n        this.reportEvent({ ...event, indent: indent + 1, measure });\n      } catch {\n        // If measuring fails (e.g., marks don't exist), silently skip this event\n        // to avoid crashing the application\n      }\n    });\n  }\n\n  private start(id: string): PerformanceMark {\n    return performance.mark(idStart(id));\n  }\n\n  private storeEvent({\n    result,\n    ...event\n  }: Pick<LoggerEvent, 'events' | 'id' | 'name' | 'start'> & {\n    result: StoredEventResult;\n  }): void {\n    const lastEventIndex = event.events.length - 1;\n    const lastEvent = event.events[lastEventIndex];\n    if (lastEvent && !lastEvent.end) {\n      result.position = [...result.position, lastEventIndex];\n      this.storeEvent({ ...event, events: lastEvent.events, result });\n      return;\n    }\n    const length = event.events.push({ ...event, events: [] });\n    result.position = [...result.position, length - 1];\n  }\n\n  timeEvent(name: string) {\n    const id = nameToId(name);\n    const start = this.start(id);\n    const event: LoggerEvent = {\n      events: this.events,\n      id,\n      name,\n      start,\n    };\n    const result: StoredEventResult = {\n      position: [],\n    };\n    this.storeEvent({ ...event, result });\n    return {\n      mark: start,\n      timeEnd: () => this.end(result),\n    };\n  }\n}\n","import path from 'node:path';\n\nimport type { IProject } from '../project/types';\nimport { File } from './file';\nimport type { FileKeyArgs, IFileIn, IFileRegistry } from './types';\n\ntype FileId = number;\ntype FileKey = string;\n\nexport class FileRegistry implements IFileRegistry {\n  private _id: FileId = 0;\n  private _values: Map<FileKey, File> = new Map();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  get(args: FileKeyArgs): File | undefined {\n    return this._values.get(this.createFileKey(args));\n  }\n\n  isRegistered(args: FileKeyArgs): boolean {\n    return this._values.has(this.createFileKey(args));\n  }\n\n  get nextId(): FileId {\n    return this._id++;\n  }\n\n  register(file: IFileIn): File {\n    const key = this.createFileKey(file);\n\n    let result = this._values.get(key);\n    if (result) {\n      if (file.name) {\n        result.setName(file.name);\n      }\n    } else {\n      result = new File(file, this.nextId, this.project);\n    }\n\n    this._values.set(key, result);\n\n    return result;\n  }\n\n  *registered(): IterableIterator<File> {\n    for (const file of this._values.values()) {\n      yield file;\n    }\n  }\n\n  private createFileKey(args: FileKeyArgs): string {\n    const logicalPath = args.logicalFilePath.split(path.sep).join('/');\n    return `${args.external ? 'ext:' : ''}${logicalPath}${args.language ? `:${args.language}` : ''}`;\n  }\n}\n","import type { FromRef, FromRefs, Ref, Refs } from './types';\n\n/**\n * Wraps a single value in a Ref object.\n *\n * If the value is already a Ref, returns it as-is (idempotent).\n *\n * @example\n * ```ts\n * const r = ref(123); // { '~ref': 123 }\n * console.log(r['~ref']); // 123\n *\n * const r2 = ref(r); // { '~ref': 123 } (not double-wrapped)\n * ```\n */\nexport const ref = <T>(value: T): Ref<T> => {\n  if (isRef(value)) {\n    return value as Ref<T>;\n  }\n  return { '~ref': value } as Ref<T>;\n};\n\n/**\n * Converts a plain object to an object of Refs (deep, per property).\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"x\" };\n * const refs = refs(obj); // { a: { '~ref': 1 }, b: { '~ref': \"x\" } }\n * ```\n */\nexport const refs = <T extends Record<string, unknown>>(obj: T): Refs<T> => {\n  const result = {} as Refs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = ref(obj[key]);\n    }\n  }\n  return result;\n};\n\n/**\n * Unwraps a single Ref object to its value.\n *\n * @example\n * ```ts\n * const r = { '~ref': 42 };\n * const n = fromRef(r); // 42\n * console.log(n); // 42\n * ```\n */\nexport const fromRef = <T extends Ref<unknown> | undefined>(ref: T): FromRef<T> =>\n  ref?.['~ref'] as FromRef<T>;\n\n/**\n * Converts an object of Refs back to a plain object (unwraps all refs).\n *\n * @example\n * ```ts\n * const refs = { a: { '~ref': 1 }, b: { '~ref': \"x\" } };\n * const plain = fromRefs(refs); // { a: 1, b: \"x\" }\n * ```\n */\nexport const fromRefs = <T extends Refs<Record<string, unknown>>>(obj: T): FromRefs<T> => {\n  const result = {} as FromRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = fromRef(obj[key]!) as (typeof result)[typeof key];\n    }\n  }\n  return result;\n};\n\n/**\n * Checks whether a value is a Ref object.\n *\n * @param value Value to check\n * @returns True if the value is a Ref object.\n */\nexport const isRef = <T>(value: unknown): value is Ref<T> =>\n  typeof value === 'object' && value !== null && '~ref' in value;\n","import { fromRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { INode } from './node';\nimport type { INodeRegistry } from './types';\n\nexport class NodeRegistry implements INodeRegistry {\n  private list: Array<Ref<INode | null>> = [];\n\n  add(node: INode | null): number {\n    const index = this.list.push(ref(node));\n    return index - 1;\n  }\n\n  *all(): Iterable<INode> {\n    for (const r of this.list) {\n      const node = fromRef(r);\n      if (node) yield node;\n    }\n  }\n\n  remove(index: number): void {\n    this.list[index] = ref(null);\n  }\n\n  update(index: number, node: INode | null): void {\n    this.list[index] = ref(node);\n  }\n}\n","import type { SymbolKind } from '../symbols/types';\n\nconst kindRank: Record<SymbolKind, number> = {\n  class: 3,\n  enum: 4,\n  function: 5,\n  interface: 1,\n  namespace: 0,\n  type: 2,\n  var: 6,\n};\n\n/**\n * Returns true if two declarations of given kinds\n * are allowed to share the same identifier in TypeScript.\n */\nexport function canShareName(a: SymbolKind, b: SymbolKind): boolean {\n  // sort based on TypeScript merge precedence so `a` is always the weaker merge candidate\n  // ensures that asymmetric merges like `type + var` are correctly handled\n  if (kindRank[a] > kindRank[b]) {\n    [a, b] = [b, a];\n  }\n\n  switch (a) {\n    case 'interface':\n      return b === 'class' || b === 'interface';\n    case 'namespace':\n      return b === 'class' || b === 'enum' || b === 'function' || b === 'namespace';\n    case 'type':\n      // type can only merge with value-only declarations\n      return b === 'function' || b === 'var';\n    default:\n      return false;\n  }\n}\n","import type { Ref } from '../refs/types';\nimport type { Symbol } from '../symbols/symbol';\nimport type { SymbolKind } from '../symbols/types';\n\nexport type NameScopes = Map<string, Set<SymbolKind>>;\n\nexport type Scope = {\n  /** Child scopes. */\n  children: Array<Scope>;\n  /** Resolved names in this scope. */\n  localNames: NameScopes;\n  /** Parent scope, if any. */\n  parent?: Scope;\n  /** Symbols registered in this scope. */\n  symbols: Array<Ref<Symbol>>;\n};\n\nexport type AssignOptions = {\n  /** The primary scope in which to assign a symbol's final name. */\n  scope: Scope;\n  /** Additional scopes to update as side effects when assigning a symbol's final name. */\n  scopesToUpdate: ReadonlyArray<Scope>;\n};\n\nexport const createScope = (\n  args: {\n    localNames?: NameScopes;\n    parent?: Scope;\n  } = {},\n): Scope => ({\n  children: [],\n  localNames: args.localNames || new Map(),\n  parent: args.parent,\n  symbols: [],\n});\n","import { isNodeRef, isSymbolRef } from '../guards';\nimport type { INode, NodeRelationship } from '../nodes/node';\nimport { fromRef, isRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { Symbol } from '../symbols/symbol';\nimport type { NameScopes, Scope } from './scope';\nimport { createScope } from './scope';\nimport type { IAnalysisContext, Input } from './types';\n\nexport class AnalysisContext implements IAnalysisContext {\n  /**\n   * Stack of parent nodes during analysis.\n   *\n   * The top of the stack is the current semantic container.\n   */\n  private _parentStack: Array<INode> = [];\n\n  scope: Scope;\n  scopes: Scope = createScope();\n  symbol?: Symbol;\n\n  constructor(node: INode) {\n    this._parentStack.push(node);\n    this.scope = this.scopes;\n    this.symbol = node.symbol;\n  }\n\n  /**\n   * Get the current semantic parent (top of stack).\n   */\n  get currentParent(): INode | undefined {\n    return this._parentStack[this._parentStack.length - 1];\n  }\n\n  /**\n   * Register a child node under the current parent.\n   */\n  addChild(child: INode, relationship: NodeRelationship = 'container'): void {\n    const parent = this.currentParent;\n    if (!parent) return;\n\n    if (!parent.structuralChildren) {\n      parent.structuralChildren = new Map();\n    }\n    parent.structuralChildren.set(child, relationship);\n\n    if (!child.structuralParents) {\n      child.structuralParents = new Map();\n    }\n    child.structuralParents.set(parent, relationship);\n  }\n\n  addDependency(symbol: Ref<Symbol>): void {\n    if (this.symbol !== fromRef(symbol)) {\n      this.scope.symbols.push(symbol);\n    }\n  }\n\n  analyze(input: Input): void {\n    const value = isRef(input) ? input : ref(input);\n    if (isSymbolRef(value)) {\n      const symbol = fromRef(value);\n      // avoid adding self as child\n      if (symbol.node && this.currentParent !== symbol.node) {\n        this.addChild(symbol.node, 'reference');\n      }\n      this.addDependency(value);\n    } else if (isNodeRef(value)) {\n      const node = fromRef(value);\n      this.addChild(node, 'container');\n      this.pushParent(node);\n      node.analyze(this);\n      this.popParent();\n    }\n  }\n\n  localNames(scope: Scope): NameScopes {\n    const names: NameScopes = new Map();\n    for (const [name, kinds] of scope.localNames) {\n      names.set(name, new Set(kinds));\n    }\n    if (scope.parent) {\n      const parentNames = this.localNames(scope.parent);\n      for (const [name, kinds] of parentNames) {\n        if (!names.has(name)) {\n          names.set(name, kinds);\n        } else {\n          const existingKinds = names.get(name)!;\n          for (const kind of kinds) {\n            existingKinds.add(kind);\n          }\n        }\n      }\n    }\n    return names;\n  }\n\n  /**\n   * Pop the current semantic parent.\n   * Call this when exiting a container node.\n   */\n  popParent(): void {\n    this._parentStack.pop();\n  }\n\n  popScope(): void {\n    this.scope = this.scope.parent ?? this.scope;\n  }\n\n  /**\n   * Push a node as the current semantic parent.\n   */\n  pushParent(node: INode): void {\n    this._parentStack.push(node);\n  }\n\n  pushScope(): void {\n    const scope = createScope({ parent: this.scope });\n    this.scope.children.push(scope);\n    this.scope = scope;\n  }\n\n  walkScopes(\n    callback: (symbol: Ref<Symbol>, scope: Scope) => void,\n    scope: Scope = this.scopes,\n  ): void {\n    this.scope = scope;\n    for (const symbol of scope.symbols) {\n      callback(symbol, scope);\n    }\n    for (const child of scope.children) {\n      scope = child;\n      this.walkScopes(callback, scope);\n    }\n    this.scope = this.scopes;\n  }\n}\n\nexport class Analyzer {\n  private nodeCache = new WeakMap<INode, AnalysisContext>();\n\n  analyzeNode(node: INode): AnalysisContext {\n    const cached = this.nodeCache.get(node);\n    if (cached) return cached;\n\n    node.root = true;\n    const ctx = new AnalysisContext(node);\n    node.analyze(ctx);\n\n    this.nodeCache.set(node, ctx);\n    return ctx;\n  }\n\n  analyze(nodes: Iterable<INode>, callback?: (ctx: AnalysisContext, node: INode) => void): void {\n    for (const node of nodes) {\n      const ctx = this.analyzeNode(node);\n      callback?.(ctx, node);\n    }\n  }\n}\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport type { IProjectRenderMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport type { INode } from '../nodes/node';\nimport { canShareName } from '../project/namespace';\nimport type { IProject } from '../project/types';\nimport { fromRef } from '../refs/refs';\nimport type { RenderContext } from '../renderer';\nimport type { Symbol } from '../symbols/symbol';\nimport type { SymbolKind } from '../symbols/types';\nimport type { AnalysisContext } from './analyzer';\nimport { Analyzer } from './analyzer';\nimport type { AssignOptions, Scope } from './scope';\nimport { createScope } from './scope';\n\nconst isTypeOnlyKind = (kind: SymbolKind) => kind === 'type' || kind === 'interface';\n\nexport class Planner {\n  private readonly analyzer = new Analyzer();\n  private readonly cacheResolvedNames = new Set<number>();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  /**\n   * Executes the planning phase for the project.\n   */\n  plan(meta?: IProjectRenderMeta) {\n    this.cacheResolvedNames.clear();\n    this.allocateFiles();\n    this.assignLocalNames();\n    this.resolveFilePaths(meta);\n    this.planExports();\n    this.planImports();\n  }\n\n  /**\n   * Creates and assigns a file to every node, re-export,\n   * and external dependency.\n   */\n  private allocateFiles(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = this.project.files.register({\n        external: false,\n        language: node.language,\n        logicalFilePath: symbol.getFilePath?.(symbol) || this.project.defaultFileName,\n      });\n      file.addNode(node);\n      symbol.setFile(file);\n      for (const logicalFilePath of symbol.getExportFromFilePath?.(symbol) ?? []) {\n        this.project.files.register({\n          external: false,\n          language: file.language,\n          logicalFilePath,\n        });\n      }\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (dep.external && dep.isCanonical && !dep.file) {\n          const file = this.project.files.register({\n            external: true,\n            language: dep.node?.language,\n            logicalFilePath: dep.external,\n          });\n          dep.setFile(file);\n        }\n      });\n    });\n  }\n\n  /**\n   * Assigns final names to all symbols.\n   *\n   * First assigns top-level (file-scoped) symbol names, then local symbols.\n   */\n  private assignLocalNames(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n      this.assignTopLevelName({ ctx, node, symbol });\n    });\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const file = node.file;\n      if (!file) return;\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        // top-level or external symbol\n        if (dep.file) return;\n        // TODO: pass node\n        this.assignLocalName({\n          ctx,\n          file,\n          scopesToUpdate: [createScope({ localNames: file.allNames })],\n          symbol: dep,\n        });\n      });\n    });\n  }\n\n  /**\n   * Resolves and sets final file paths for all non-external files. Attaches renderers.\n   *\n   * Uses the project's fileName function if provided, otherwise uses the file's current name.\n   *\n   * Resolves final paths relative to the project's root directory.\n   */\n  private resolveFilePaths(meta?: IProjectRenderMeta): void {\n    for (const file of this.project.files.registered()) {\n      if (file.external) {\n        file.setFinalPath(file.logicalFilePath);\n        continue;\n      }\n      const finalName = this.project.fileName?.(file.name) || file.name;\n      file.setName(finalName);\n      const finalPath = file.finalPath;\n      if (finalPath) {\n        file.setFinalPath(path.resolve(this.project.root, finalPath));\n      }\n      const ctx: RenderContext = { file, meta, project: this.project };\n      const renderer = this.project.renderers.find((r) => r.supports(ctx));\n      if (renderer) file.setRenderer(renderer);\n    }\n  }\n\n  /**\n   * Plans exports by analyzing all exported symbols.\n   *\n   * Registers re-export targets as files and creates new exported symbols for them.\n   *\n   * Assigns names to re-exported symbols and collects re-export metadata,\n   * distinguishing type-only exports based on symbol kinds.\n   */\n  private planExports(): void {\n    const seenByFile = new Map<File, Map<string, { kinds: Set<SymbolKind>; symbol: Symbol }>>();\n    const sourceFile = new Map<number, File>();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      if (!node.exported) return;\n\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = node.file;\n      if (!file) return;\n\n      for (const logicalFilePath of symbol.getExportFromFilePath?.(symbol) ?? []) {\n        const target = this.project.files.register({\n          external: false,\n          language: node.language,\n          logicalFilePath,\n        });\n        if (target.id === file.id) continue;\n\n        let fileMap = seenByFile.get(target);\n        if (!fileMap) {\n          fileMap = new Map();\n          seenByFile.set(target, fileMap);\n        }\n\n        const exp = this.project.symbols.register({\n          exported: true,\n          external: symbol.external,\n          importKind: symbol.importKind,\n          kind: symbol.kind,\n          name: symbol.finalName,\n        });\n        exp.setFile(target);\n        sourceFile.set(exp.id, file);\n        // TODO: pass node\n        this.assignTopLevelName({ ctx, symbol: exp });\n\n        let entry = fileMap.get(exp.finalName);\n        if (!entry) {\n          entry = { kinds: new Set(), symbol: exp };\n          fileMap.set(exp.finalName, entry);\n        }\n        entry.kinds.add(exp.kind);\n      }\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const exports = new Map<File, ExportModule>();\n      for (const [, entry] of fileMap) {\n        const source = sourceFile.get(entry.symbol.id)!;\n        let exp = exports.get(source);\n        if (!exp) {\n          exp = {\n            canExportAll: true,\n            exports: [],\n            from: source,\n            isTypeOnly: true,\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) => isTypeOnlyKind(kind));\n        const exportedName = entry.symbol.finalName;\n        exp.exports.push({\n          exportedName,\n          isTypeOnly,\n          kind: entry.symbol.importKind,\n          sourceName: entry.symbol.name,\n        });\n        if (entry.symbol.name !== entry.symbol.finalName) {\n          exp.canExportAll = false;\n        }\n        if (!isTypeOnly) {\n          exp.isTypeOnly = false;\n        }\n        exports.set(source, exp);\n      }\n      for (const [, exp] of exports) {\n        file.addExport(exp);\n      }\n    }\n  }\n\n  /**\n   * Plans imports by analyzing symbol dependencies across files.\n   *\n   * For external dependencies, assigns top-level names.\n   *\n   * Creates or reuses import symbols for dependencies from other files,\n   * assigning names and updating import metadata including type-only flags.\n   */\n  private planImports(): void {\n    const seenByFile = new Map<\n      File,\n      Map<\n        string,\n        {\n          dep: Symbol;\n          kinds: Set<SymbolKind>;\n          symbol: Symbol;\n        }\n      >\n    >();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx) => {\n      const symbol = ctx.symbol;\n      if (!symbol) return;\n\n      const file = symbol.file;\n      if (!file) return;\n\n      let fileMap = seenByFile.get(file);\n      if (!fileMap) {\n        fileMap = new Map();\n        seenByFile.set(file, fileMap);\n      }\n\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (!dep.file || dep.file.id === file.id) return;\n\n        if (dep.external) {\n          // TODO: pass node\n          this.assignTopLevelName({ ctx, symbol: dep });\n        }\n\n        const fromFileId = dep.file.id;\n        const importedName = dep.finalName;\n        const kind = dep.importKind;\n        const key = `${fromFileId}|${importedName}|${kind}`;\n\n        let entry = fileMap.get(key);\n        if (!entry) {\n          const imp = this.project.symbols.register({\n            exported: dep.exported,\n            external: dep.external,\n            importKind: dep.importKind,\n            kind: dep.kind,\n            name: dep.finalName,\n          });\n          imp.setFile(file);\n          // TODO: pass node\n          this.assignTopLevelName({\n            ctx,\n            scope: createScope({ localNames: imp.file!.allNames }),\n            symbol: imp,\n          });\n          entry = {\n            dep,\n            kinds: new Set(),\n            symbol: imp,\n          };\n          fileMap.set(key, entry);\n        }\n        entry.kinds.add(dep.kind);\n\n        dependency['~ref'] = entry.symbol;\n      });\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const imports = new Map<File, ImportModule>();\n      for (const [, entry] of fileMap) {\n        const source = entry.dep.file!;\n        let imp = imports.get(source);\n        if (!imp) {\n          imp = {\n            from: source,\n            imports: [],\n            isTypeOnly: true,\n            kind: 'named',\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) => isTypeOnlyKind(kind));\n        if (entry.symbol.importKind === 'namespace') {\n          imp.imports = [];\n          imp.kind = 'namespace';\n          imp.localName = entry.symbol.finalName;\n        } else if (entry.symbol.importKind === 'default') {\n          imp.kind = 'default';\n          imp.localName = entry.symbol.finalName;\n        } else {\n          imp.imports.push({\n            isTypeOnly,\n            localName: entry.symbol.finalName,\n            sourceName: entry.dep.finalName,\n          });\n        }\n        if (!isTypeOnly) {\n          imp.isTypeOnly = false;\n        }\n        imports.set(source, imp);\n      }\n      for (const [, imp] of imports) {\n        file.addImport(imp);\n      }\n    }\n  }\n\n  /**\n   * Assigns the final name to a top-level (file-scoped) symbol.\n   *\n   * Uses the symbol's file top-level names as the default scope,\n   * and updates all relevant name scopes including the file's allNames and local scopes.\n   *\n   * Supports optional overrides for the naming scope and scopes to update.\n   */\n  private assignTopLevelName(\n    args: Partial<AssignOptions> & {\n      ctx: AnalysisContext;\n      debug?: boolean;\n      node?: INode;\n      symbol: Symbol;\n    },\n  ): void {\n    if (!args.symbol.file) return;\n    this.assignSymbolName({\n      ...args,\n      file: args.symbol.file,\n      scope: args?.scope ?? createScope({ localNames: args.symbol.file.topLevelNames }),\n      scopesToUpdate: [\n        createScope({ localNames: args.symbol.file.allNames }),\n        args.ctx.scopes,\n        ...(args?.scopesToUpdate ?? []),\n      ],\n    });\n  }\n\n  /**\n   * Assigns the final name to a non-top-level (local) symbol.\n   *\n   * Uses the provided scope or derives it from the current analysis context's local names.\n   *\n   * Updates all provided name scopes accordingly.\n   */\n  private assignLocalName(\n    args: Pick<Partial<AssignOptions>, 'scope'> &\n      Pick<AssignOptions, 'scopesToUpdate'> & {\n        ctx: AnalysisContext;\n        debug?: boolean;\n        /** The file the symbol belongs to. */\n        file: File;\n        node?: INode;\n        symbol: Symbol;\n      },\n  ): void {\n    this.assignSymbolName({\n      ...args,\n      scope: args.scope ?? args.ctx.scope,\n    });\n  }\n\n  /**\n   * Assigns the final name to a symbol within the provided name scope.\n   *\n   * Resolves name conflicts until a unique name is found.\n   *\n   * Updates all specified name scopes with the assigned final name.\n   */\n  private assignSymbolName(\n    args: AssignOptions & {\n      ctx: AnalysisContext;\n      debug?: boolean;\n      /** The file the symbol belongs to. */\n      file: File;\n      node?: INode;\n      symbol: Symbol;\n    },\n  ): void {\n    const { ctx, file, node, scope, scopesToUpdate, symbol } = args;\n    if (this.cacheResolvedNames.has(symbol.id)) return;\n\n    const baseName = symbol.name;\n    let finalName =\n      node?.nameSanitizer?.(baseName) ?? symbol.node?.nameSanitizer?.(baseName) ?? baseName;\n    let attempt = 1;\n\n    const localNames = ctx.localNames(scope);\n    while (true) {\n      const kinds = [...(localNames.get(finalName) ?? [])];\n\n      const ok = kinds.every((kind) => canShareName(symbol.kind, kind));\n      if (ok) break;\n\n      const language = node?.language || symbol.node?.language || file.language;\n      const resolver =\n        (language ? this.project.nameConflictResolvers[language] : undefined) ??\n        this.project.defaultNameConflictResolver;\n      const resolvedName = resolver({ attempt, baseName });\n      if (!resolvedName) {\n        throw new Error(`Unresolvable name conflict: ${symbol.toString()}`);\n      }\n\n      finalName =\n        node?.nameSanitizer?.(resolvedName) ??\n        symbol.node?.nameSanitizer?.(resolvedName) ??\n        resolvedName;\n      attempt = attempt + 1;\n    }\n\n    symbol.setFinalName(finalName);\n    this.cacheResolvedNames.add(symbol.id);\n    const updateScopes = [scope, ...scopesToUpdate];\n    for (const scope of updateScopes) {\n      this.updateScope(symbol, scope);\n    }\n  }\n\n  /**\n   * Updates the provided name scope with the symbol's final name and kind.\n   *\n   * Ensures the name scope tracks all kinds associated with a given name.\n   */\n  private updateScope(symbol: Symbol, scope: Scope): void {\n    const name = symbol.finalName;\n    const cache = scope.localNames.get(name) ?? new Set();\n    cache.add(symbol.kind);\n    scope.localNames.set(name, cache);\n  }\n}\n","import { symbolBrand } from '../brands';\nimport type { ISymbolMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport { log } from '../log';\nimport type { INode } from '../nodes/node';\nimport type { BindingKind, ISymbolIn, SymbolKind } from './types';\n\nexport class Symbol<Node extends INode = INode> {\n  /**\n   * Canonical symbol this stub resolves to, if any.\n   *\n   * Stubs created during DSL construction may later be associated\n   * with a fully registered symbol. Once set, all property lookups\n   * should defer to the canonical symbol.\n   */\n  private _canonical?: Symbol;\n  /**\n   * True if this symbol is exported from its defining file.\n   *\n   * @default false\n   */\n  private _exported: boolean;\n  /**\n   * External module name if this symbol is imported from a module not managed\n   * by the project (e.g. \"zod\", \"lodash\").\n   *\n   * @default undefined\n   */\n  private _external?: string;\n  /**\n   * The file this symbol is ultimately emitted into.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  private _file?: File;\n  /**\n   * The alias-resolved, conflict-free emitted name.\n   */\n  private _finalName?: string;\n  /**\n   * Custom strategy to determine from which file path(s) this symbol is re-exported.\n   *\n   * @returns The file path(s) that re-export this symbol, or undefined if none.\n   */\n  private _getExportFromFilePath?: (symbol: Symbol) => ReadonlyArray<string> | undefined;\n  /**\n   * Custom strategy to determine file output path.\n   *\n   * @returns The file path to output the symbol to, or undefined to fallback to default behavior.\n   */\n  private _getFilePath?: (symbol: Symbol) => string | undefined;\n  /**\n   * How this symbol should be imported (namespace/default/named).\n   *\n   * @default 'named'\n   */\n  private _importKind: BindingKind;\n  /**\n   * Kind of symbol (class, type, alias, etc.).\n   *\n   * @default 'var'\n   */\n  private _kind: SymbolKind;\n  /**\n   * Arbitrary user metadata.\n   *\n   * @default undefined\n   */\n  private _meta?: ISymbolMeta;\n  /**\n   * Intended user-facing name before conflict resolution.\n   *\n   * @example \"UserModel\"\n   */\n  private _name: string;\n  /**\n   * Node that defines this symbol.\n   */\n  private _node?: Node;\n\n  /** Brand used for identifying symbols. */\n  readonly '~brand' = symbolBrand;\n  /** Globally unique, stable symbol ID. */\n  readonly id: number;\n\n  constructor(input: ISymbolIn, id: number) {\n    this._exported = input.exported ?? false;\n    this._external = input.external;\n    this._getExportFromFilePath = input.getExportFromFilePath;\n    this._getFilePath = input.getFilePath;\n    this.id = id;\n    this._importKind = input.importKind ?? 'named';\n    this._kind = input.kind ?? 'var';\n    this._meta = input.meta;\n    this._name = input.name;\n  }\n\n  /**\n   * Returns the canonical symbol for this instance.\n   *\n   * If this symbol was created as a stub, this getter returns\n   * the fully registered canonical symbol. Otherwise, it returns\n   * the symbol itself.\n   */\n  get canonical(): Symbol {\n    return this._canonical ?? this;\n  }\n\n  /**\n   * Indicates whether this symbol is exported from its defining file.\n   */\n  get exported(): boolean {\n    return this.canonical._exported;\n  }\n\n  /**\n   * External module from which this symbol originates, if any.\n   */\n  get external(): string | undefined {\n    return this.canonical._external;\n  }\n\n  /**\n   * Read‑only accessor for the assigned output file.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  get file(): File | undefined {\n    return this.canonical._file;\n  }\n\n  /**\n   * Read‑only accessor for the resolved final emitted name.\n   */\n  get finalName(): string {\n    if (!this.canonical._finalName) {\n      const message = `Symbol finalName has not been resolved yet for ${this.canonical.toString()}`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    return this.canonical._finalName;\n  }\n\n  /**\n   * Custom re-export file path resolver, if provided.\n   */\n  get getExportFromFilePath(): ((symbol: Symbol) => ReadonlyArray<string> | undefined) | undefined {\n    return this.canonical._getExportFromFilePath;\n  }\n\n  /**\n   * Custom file path resolver, if provided.\n   */\n  get getFilePath(): ((symbol: Symbol) => string | undefined) | undefined {\n    return this.canonical._getFilePath;\n  }\n\n  /**\n   * How this symbol should be imported (named/default/namespace).\n   */\n  get importKind(): BindingKind {\n    return this.canonical._importKind;\n  }\n\n  /**\n   * Indicates whether this is a canonical symbol (not a stub).\n   */\n  get isCanonical(): boolean {\n    return !this._canonical || this._canonical === this;\n  }\n\n  /**\n   * The symbol's kind (class, type, alias, variable, etc.).\n   */\n  get kind(): SymbolKind {\n    return this.canonical._kind;\n  }\n\n  /**\n   * Arbitrary user‑provided metadata associated with this symbol.\n   */\n  get meta(): ISymbolMeta | undefined {\n    return this.canonical._meta;\n  }\n\n  /**\n   * User-intended name before aliasing or conflict resolution.\n   */\n  get name(): string {\n    return this.canonical._name;\n  }\n\n  /**\n   * Read‑only accessor for the defining node.\n   */\n  get node(): Node | undefined {\n    return this.canonical._node as Node | undefined;\n  }\n\n  /**\n   * Marks this symbol as a stub and assigns its canonical symbol.\n   *\n   * After calling this, all semantic queries (name, kind, file,\n   * meta, etc.) should reflect the canonical symbol's values.\n   *\n   * @param symbol — The canonical symbol this stub should resolve to.\n   */\n  setCanonical(symbol: Symbol): void {\n    this._canonical = symbol;\n  }\n\n  /**\n   * Marks the symbol as exported from its file.\n   *\n   * @param exported — Whether the symbol is exported.\n   */\n  setExported(exported: boolean): void {\n    this.assertCanonical();\n    this._exported = exported;\n  }\n\n  /**\n   * Assigns the output file this symbol will be emitted into.\n   *\n   * This may only be set once.\n   */\n  setFile(file: File): void {\n    this.assertCanonical();\n    if (this._file && this._file !== file) {\n      const message = `Symbol ${this.canonical.toString()} is already assigned to a different file.`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._file = file;\n  }\n\n  /**\n   * Assigns the conflict‑resolved final local name for this symbol.\n   *\n   * This may only be set once.\n   */\n  setFinalName(name: string): void {\n    this.assertCanonical();\n    if (this._finalName && this._finalName !== name) {\n      const message = `Symbol finalName has already been resolved for ${this.canonical.toString()}.`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._finalName = name;\n  }\n\n  /**\n   * Sets how this symbol should be imported.\n   *\n   * @param kind — The import strategy (named/default/namespace).\n   */\n  setImportKind(kind: BindingKind): void {\n    this.assertCanonical();\n    this._importKind = kind;\n  }\n\n  /**\n   * Sets the symbol's kind (class, type, alias, variable, etc.).\n   *\n   * @param kind — The new symbol kind.\n   */\n  setKind(kind: SymbolKind): void {\n    this.assertCanonical();\n    this._kind = kind;\n  }\n\n  /**\n   * Updates the intended user‑facing name for this symbol.\n   *\n   * @param name — The new name.\n   */\n  setName(name: string): void {\n    this.assertCanonical();\n    this._name = name;\n  }\n\n  /**\n   * Binds the node that defines this symbol.\n   *\n   * This may only be set once.\n   */\n  setNode(node: Node): void {\n    this.assertCanonical();\n    if (this._node && this._node !== node) {\n      const message = `Symbol ${this.canonical.toString()} is already bound to a different node.`;\n      log.debug(message, 'symbol');\n      // TODO: symbol <> node relationship needs to be refactor to 1:many\n      // disabled in the meantime or it would throw\n      // throw new Error(message);\n    }\n    this._node = node;\n    node.symbol = this;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the symbol.\n   */\n  toString(): string {\n    const canonical = this.canonical;\n    if (canonical._finalName && canonical._finalName !== canonical._name) {\n      return `[Symbol ${canonical._name} → ${canonical._finalName}#${canonical.id}]`;\n    }\n    return `[Symbol ${canonical._name}#${canonical.id}]`;\n  }\n\n  /**\n   * Ensures this symbol is canonical before allowing mutation.\n   *\n   * A symbol that has been marked as a stub (i.e., its `_canonical` points\n   * to a different symbol) may not be mutated. This guard throws an error\n   * if any setter attempts to modify a stub, preventing accidental writes\n   * to non‑canonical instances.\n   *\n   * @throws {Error} If the symbol is a stub and is being mutated.\n   */\n  private assertCanonical(): void {\n    if (this._canonical && this._canonical !== this) {\n      const message = `Illegal mutation of stub symbol ${this.toString()} → canonical: ${this._canonical.toString()}`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n  }\n}\n","import type { ISymbolMeta } from '../extensions';\nimport { Symbol } from './symbol';\nimport type { ISymbolIdentifier, ISymbolIn, ISymbolRegistry } from './types';\n\ntype IndexEntry = [string, unknown];\ntype IndexKeySpace = ReadonlyArray<IndexEntry>;\ntype QueryCacheKey = string;\ntype SymbolId = number;\n\nexport class SymbolRegistry implements ISymbolRegistry {\n  private _id: SymbolId = 0;\n  private _indices: Map<IndexEntry[0], Map<IndexEntry[1], Set<SymbolId>>> = new Map();\n  private _queryCache: Map<QueryCacheKey, ReadonlyArray<SymbolId>> = new Map();\n  private _queryCacheDependencies: Map<QueryCacheKey, Set<QueryCacheKey>> = new Map();\n  private _registered: Set<SymbolId> = new Set();\n  private _stubs: Set<SymbolId> = new Set();\n  private _stubCache: Map<QueryCacheKey, SymbolId> = new Map();\n  private _values: Map<SymbolId, Symbol> = new Map();\n\n  get(identifier: ISymbolIdentifier): Symbol | undefined {\n    return typeof identifier === 'number'\n      ? this._values.get(identifier)\n      : this.query(identifier)[0];\n  }\n\n  isRegistered(identifier: ISymbolIdentifier): boolean {\n    const symbol = this.get(identifier);\n    return symbol ? this._registered.has(symbol.id) : false;\n  }\n\n  get nextId(): SymbolId {\n    return this._id++;\n  }\n\n  query(filter: ISymbolMeta): ReadonlyArray<Symbol> {\n    const cacheKey = this.buildCacheKey(filter);\n    const cachedIds = this._queryCache.get(cacheKey);\n    if (cachedIds) {\n      return cachedIds.map((symbolId) => this._values.get(symbolId)!);\n    }\n    const sets: Array<Set<SymbolId>> = [];\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    const cacheDependencies = new Set<QueryCacheKey>();\n    let missed = false;\n    for (const indexEntry of indexKeySpace) {\n      cacheDependencies.add(this.serializeIndexEntry(indexEntry));\n      const values = this._indices.get(indexEntry[0]);\n      if (!values) {\n        missed = true;\n        break;\n      }\n      const set = values.get(indexEntry[1]);\n      if (!set) {\n        missed = true;\n        break;\n      }\n      sets.push(set);\n    }\n    if (missed || !sets.length) {\n      this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n      this._queryCache.set(cacheKey, []);\n      return [];\n    }\n    let result = new Set(sets[0]);\n    for (const set of sets.slice(1)) {\n      result = new Set([...result].filter((symbolId) => set.has(symbolId)));\n    }\n    const resultIds = [...result];\n    this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n    this._queryCache.set(cacheKey, resultIds);\n    return resultIds.map((symbolId) => this._values.get(symbolId)!);\n  }\n\n  reference(meta: ISymbolMeta): Symbol {\n    const [registered] = this.query(meta);\n    if (registered) return registered;\n\n    const cacheKey = this.buildCacheKey(meta);\n    const cachedId = this._stubCache.get(cacheKey);\n    if (cachedId !== undefined) return this._values.get(cachedId)!;\n\n    const stub = new Symbol({ meta, name: '' }, this.nextId);\n\n    this._values.set(stub.id, stub);\n    this._stubs.add(stub.id);\n    this._stubCache.set(cacheKey, stub.id);\n    return stub;\n  }\n\n  register(symbol: ISymbolIn): Symbol {\n    const result = new Symbol(symbol, this.nextId);\n\n    this._values.set(result.id, result);\n    this._registered.add(result.id);\n\n    if (result.meta) {\n      const indexKeySpace = this.buildIndexKeySpace(result.meta);\n      this.indexSymbol(result.id, indexKeySpace);\n      this.invalidateCache(indexKeySpace);\n      this.replaceStubs(result, indexKeySpace);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<Symbol> {\n    for (const id of this._registered.values()) {\n      yield this._values.get(id)!;\n    }\n  }\n\n  private buildCacheKey(filter: ISymbolMeta): QueryCacheKey {\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    return indexKeySpace\n      .map((indexEntry) => this.serializeIndexEntry(indexEntry))\n      .sort() // ensure order-insensitivity\n      .join('|');\n  }\n\n  private buildIndexKeySpace(meta: ISymbolMeta, prefix = ''): IndexKeySpace {\n    const entries: Array<IndexEntry> = [];\n    for (const [key, value] of Object.entries(meta)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        entries.push(...this.buildIndexKeySpace(value as ISymbolMeta, path));\n      } else {\n        entries.push([path, value]);\n      }\n    }\n    return entries;\n  }\n\n  private indexSymbol(symbolId: SymbolId, indexKeySpace: IndexKeySpace): void {\n    for (const [key, value] of indexKeySpace) {\n      if (!this._indices.has(key)) this._indices.set(key, new Map());\n      const values = this._indices.get(key)!;\n      const set = values.get(value) ?? new Set();\n      set.add(symbolId);\n      values.set(value, set);\n    }\n  }\n\n  private invalidateCache(indexKeySpace: IndexKeySpace): void {\n    const changed = indexKeySpace.map((indexEntry) => this.serializeIndexEntry(indexEntry));\n    for (const [cacheKey, cacheDependencies] of this._queryCacheDependencies.entries()) {\n      for (const key of changed) {\n        if (cacheDependencies.has(key)) {\n          this._queryCacheDependencies.delete(cacheKey);\n          this._queryCache.delete(cacheKey);\n          break;\n        }\n      }\n    }\n  }\n\n  private isSubset(sub: IndexKeySpace, sup: IndexKeySpace): boolean {\n    const supMap = new Map(sup);\n    for (const [key, value] of sub) {\n      if (!supMap.has(key) || supMap.get(key) !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private replaceStubs(symbol: Symbol, indexKeySpace: IndexKeySpace): void {\n    for (const stubId of this._stubs.values()) {\n      const stub = this._values.get(stubId);\n      if (stub?.meta && this.isSubset(this.buildIndexKeySpace(stub.meta), indexKeySpace)) {\n        const cacheKey = this.buildCacheKey(stub.meta);\n        this._stubCache.delete(cacheKey);\n        this._stubs.delete(stubId);\n        stub.setCanonical(symbol);\n      }\n    }\n  }\n\n  private serializeIndexEntry(indexEntry: IndexEntry): string {\n    return `${indexEntry[0]}:${JSON.stringify(indexEntry[1])}`;\n  }\n}\n","import path from 'node:path';\n\nimport type { IProjectRenderMeta } from '../extensions';\nimport { FileRegistry } from '../files/registry';\nimport { defaultExtensions } from '../languages/extensions';\nimport { defaultModuleEntryNames } from '../languages/modules';\nimport { defaultNameConflictResolvers } from '../languages/resolvers';\nimport type { Extensions, ModuleEntryNames, NameConflictResolvers } from '../languages/types';\nimport { NodeRegistry } from '../nodes/registry';\nimport type { IOutput } from '../output';\nimport { Planner } from '../planner/planner';\nimport { simpleNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolver } from '../planner/types';\nimport type { Renderer } from '../renderer';\nimport { SymbolRegistry } from '../symbols/registry';\nimport type { IProject } from './types';\n\nexport class Project implements IProject {\n  private _isPlanned = false;\n\n  readonly files: FileRegistry;\n  readonly nodes = new NodeRegistry();\n  readonly symbols = new SymbolRegistry();\n\n  readonly defaultFileName: string;\n  readonly defaultNameConflictResolver: NameConflictResolver;\n  readonly extensions: Extensions;\n  readonly fileName?: (name: string) => string;\n  readonly moduleEntryNames: ModuleEntryNames;\n  readonly nameConflictResolvers: NameConflictResolvers;\n  readonly renderers: ReadonlyArray<Renderer>;\n  readonly root: string;\n\n  constructor(\n    args: Pick<\n      Partial<IProject>,\n      | 'defaultFileName'\n      | 'defaultNameConflictResolver'\n      | 'extensions'\n      | 'fileName'\n      | 'moduleEntryNames'\n      | 'nameConflictResolvers'\n      | 'renderers'\n    > &\n      Pick<IProject, 'root'>,\n  ) {\n    const fileName = args.fileName;\n    this.defaultFileName = args.defaultFileName ?? 'main';\n    this.defaultNameConflictResolver =\n      args.defaultNameConflictResolver ?? simpleNameConflictResolver;\n    this.extensions = {\n      ...defaultExtensions,\n      ...args.extensions,\n    };\n    this.fileName = typeof fileName === 'string' ? () => fileName : fileName;\n    this.files = new FileRegistry(this);\n    this.moduleEntryNames = {\n      ...defaultModuleEntryNames,\n      ...args.moduleEntryNames,\n    };\n    this.nameConflictResolvers = {\n      ...defaultNameConflictResolvers,\n      ...args.nameConflictResolvers,\n    };\n    this.renderers = args.renderers ?? [];\n    this.root = path.resolve(args.root).replace(/[/\\\\]+$/, '');\n  }\n\n  plan(meta?: IProjectRenderMeta): void {\n    if (this._isPlanned) return;\n    new Planner(this).plan(meta);\n    this._isPlanned = true;\n  }\n\n  render(meta?: IProjectRenderMeta): ReadonlyArray<IOutput> {\n    if (!this._isPlanned) this.plan(meta);\n    const files: Array<IOutput> = [];\n    for (const file of this.files.registered()) {\n      if (!file.external && file.finalPath && file.renderer) {\n        const content = file.renderer.render({ file, meta, project: this });\n        files.push({ content, path: file.finalPath });\n      }\n    }\n    return files;\n  }\n}\n","import type { StructureItem, StructureShell } from './types';\n\nexport class StructureNode {\n  /** Nested nodes within this node. */\n  children: Map<string, StructureNode> = new Map();\n  /** Items contained in this node. */\n  items: Array<StructureItem> = [];\n  /** The name of this node (e.g., \"Users\", \"Accounts\"). */\n  name: string;\n  /** Parent node in the hierarchy. Undefined if this is the root node. */\n  parent?: StructureNode;\n  /** Shell claimed for this node. */\n  shell?: StructureShell;\n  /** Source of the claimed shell. */\n  shellSource?: symbol;\n  /** True if this is a virtual root. */\n  virtual: boolean;\n\n  constructor(\n    name: string,\n    parent?: StructureNode,\n    options?: {\n      virtual?: boolean;\n    },\n  ) {\n    this.name = name;\n    this.parent = parent;\n    this.virtual = options?.virtual ?? false;\n  }\n\n  get isRoot(): boolean {\n    return !this.parent;\n  }\n\n  /**\n   * Gets or creates a child node.\n   *\n   * If the child doesn't exist, it's created automatically.\n   *\n   * @param name - The name of the child node\n   * @returns The child node instance\n   */\n  child(name: string): StructureNode {\n    if (!this.children.has(name)) {\n      this.children.set(name, new StructureNode(name, this));\n    }\n    return this.children.get(name)!;\n  }\n\n  /**\n   * Gets the full path of this node in the hierarchy.\n   *\n   * @returns An array of node names from the root to this node\n   */\n  getPath(): ReadonlyArray<string> {\n    const path: Array<string> = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let cursor: StructureNode | undefined = this;\n    while (cursor) {\n      path.unshift(cursor.name);\n      cursor = cursor.parent;\n    }\n    return path;\n  }\n\n  /**\n   * Yields items from a specific source with typed data.\n   *\n   * @param source - The source symbol to filter by\n   * @returns Generator of items from that source\n   */\n  *itemsFrom<T = unknown>(source: symbol): Generator<StructureItem & { data: T }> {\n    for (const item of this.items) {\n      if (item.source === source) {\n        yield item as StructureItem & { data: T };\n      }\n    }\n  }\n\n  /**\n   * Walk all nodes in the structure (depth-first, post-order).\n   *\n   * @returns Generator of all structure nodes\n   */\n  *walk(): Generator<StructureNode> {\n    for (const node of this.children.values()) {\n      yield* node.walk();\n    }\n    yield this;\n  }\n}\n","import { StructureNode } from './node';\nimport type { StructureInsert } from './types';\n\nexport class StructureModel {\n  /** Root nodes mapped by their names. */\n  private _roots: Map<string, StructureNode> = new Map();\n  /** Node for data without a specific root. */\n  private _virtualRoot?: StructureNode;\n\n  /**\n   * Get all root nodes.\n   */\n  get roots(): ReadonlyArray<StructureNode> {\n    const roots = Array.from(this._roots.values());\n    if (this._virtualRoot) roots.unshift(this._virtualRoot);\n    return roots;\n  }\n\n  /**\n   * Insert data into the structure.\n   */\n  insert(args: StructureInsert): void {\n    const { data, locations, source } = args;\n    for (const location of locations) {\n      const { path, shell } = location;\n      const fullPath = path.filter((s): s is string => Boolean(s));\n      const segments = fullPath.slice(0, -1);\n      const name = fullPath[fullPath.length - 1];\n\n      if (!name) {\n        throw new Error('Cannot insert data without path.');\n      }\n\n      let cursor: StructureNode | null = null;\n\n      for (const segment of segments) {\n        if (!cursor) {\n          cursor = this.root(segment);\n        } else {\n          cursor = cursor.child(segment);\n        }\n\n        if (shell && !cursor.shell) {\n          cursor.shell = shell;\n          cursor.shellSource = source;\n        }\n      }\n\n      if (!cursor) {\n        cursor = this.root(null);\n      }\n\n      cursor.items.push({ data, location: fullPath, source });\n    }\n  }\n\n  /**\n   * Gets or creates a root by name.\n   *\n   * If the root doesn't exist, it's created automatically.\n   *\n   * @param name - The name of the root\n   * @returns The root instance\n   */\n  root(name: string | null): StructureNode {\n    if (!name) {\n      return (this._virtualRoot ??= new StructureNode('', undefined, {\n        virtual: true,\n      }));\n    }\n    if (!this._roots.has(name)) {\n      this._roots.set(name, new StructureNode(name));\n    }\n    return this._roots.get(name)!;\n  }\n\n  /**\n   * Walk all nodes in the structure (depth-first, post-order).\n   *\n   * @returns Generator of all structure nodes\n   */\n  *walk(): Generator<StructureNode> {\n    if (this._virtualRoot) {\n      yield* this._virtualRoot.walk();\n    }\n    for (const root of this._roots.values()) {\n      yield* root.walk();\n    }\n  }\n}\n"],"mappings":"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"}