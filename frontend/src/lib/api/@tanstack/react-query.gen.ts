// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { aiWriteApiV1AiWritePost, createCertificationApiV1CertificationsPost, createPostApiV1PostsPost, createProjectApiV1ProjectsPost, deleteCertificationApiV1CertificationsCertIdDelete, deletePostApiV1PostsSlugDelete, deleteProjectApiV1ProjectsSlugDelete, getCertificationApiV1CertificationsCertIdGet, getCertificationsApiV1CertificationsGet, getFeaturedProjectsApiV1ProjectsFeaturedGet, getPostApiV1PostsSlugGet, getPostsApiV1PostsGet, getProjectApiV1ProjectsSlugGet, getProjectsApiV1ProjectsGet, healthHealthGet, loginApiV1AuthLoginPost, logoutApiV1AuthLogoutPost, meApiV1AuthMeGet, type Options, updateCertificationApiV1CertificationsCertIdPatch, updatePostApiV1PostsSlugPatch, updateProjectApiV1ProjectsSlugPatch } from '../sdk.gen';
import type { AiWriteApiV1AiWritePostData, AiWriteApiV1AiWritePostError, CreateCertificationApiV1CertificationsPostData, CreateCertificationApiV1CertificationsPostError, CreateCertificationApiV1CertificationsPostResponse, CreatePostApiV1PostsPostData, CreatePostApiV1PostsPostError, CreatePostApiV1PostsPostResponse, CreateProjectApiV1ProjectsPostData, CreateProjectApiV1ProjectsPostError, CreateProjectApiV1ProjectsPostResponse, DeleteCertificationApiV1CertificationsCertIdDeleteData, DeleteCertificationApiV1CertificationsCertIdDeleteError, DeleteCertificationApiV1CertificationsCertIdDeleteResponse, DeletePostApiV1PostsSlugDeleteData, DeletePostApiV1PostsSlugDeleteError, DeletePostApiV1PostsSlugDeleteResponse, DeleteProjectApiV1ProjectsSlugDeleteData, DeleteProjectApiV1ProjectsSlugDeleteError, DeleteProjectApiV1ProjectsSlugDeleteResponse, GetCertificationApiV1CertificationsCertIdGetData, GetCertificationApiV1CertificationsCertIdGetError, GetCertificationApiV1CertificationsCertIdGetResponse, GetCertificationsApiV1CertificationsGetData, GetCertificationsApiV1CertificationsGetError, GetCertificationsApiV1CertificationsGetResponse, GetFeaturedProjectsApiV1ProjectsFeaturedGetData, GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, GetPostApiV1PostsSlugGetData, GetPostApiV1PostsSlugGetError, GetPostApiV1PostsSlugGetResponse, GetPostsApiV1PostsGetData, GetPostsApiV1PostsGetError, GetPostsApiV1PostsGetResponse, GetProjectApiV1ProjectsSlugGetData, GetProjectApiV1ProjectsSlugGetError, GetProjectApiV1ProjectsSlugGetResponse, GetProjectsApiV1ProjectsGetData, GetProjectsApiV1ProjectsGetError, GetProjectsApiV1ProjectsGetResponse, HealthHealthGetData, HealthHealthGetResponse, LoginApiV1AuthLoginPostData, LoginApiV1AuthLoginPostError, LoginApiV1AuthLoginPostResponse, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError, LogoutApiV1AuthLogoutPostResponse, MeApiV1AuthMeGetData, MeApiV1AuthMeGetError, MeApiV1AuthMeGetResponse, UpdateCertificationApiV1CertificationsCertIdPatchData, UpdateCertificationApiV1CertificationsCertIdPatchError, UpdateCertificationApiV1CertificationsCertIdPatchResponse, UpdatePostApiV1PostsSlugPatchData, UpdatePostApiV1PostsSlugPatchError, UpdatePostApiV1PostsSlugPatchResponse, UpdateProjectApiV1ProjectsSlugPatchData, UpdateProjectApiV1ProjectsSlugPatchError, UpdateProjectApiV1ProjectsSlugPatchResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getProjectsApiV1ProjectsGetQueryKey = (options?: Options<GetProjectsApiV1ProjectsGetData>) => createQueryKey('getProjectsApiV1ProjectsGet', options);

/**
 * Get Projects
 *
 * Retrieve a list of projects.
 *
 * Args:
 * published_only: If ``True``, returns only published projects.
 * Defaults to ``True``.
 * db: Active async database session.
 * service: Injected project service.
 *
 * Returns:
 * A list of :class:`~app.schemas.project.ProjectResponse` objects.
 */
export const getProjectsApiV1ProjectsGetOptions = (options?: Options<GetProjectsApiV1ProjectsGetData>) => queryOptions<GetProjectsApiV1ProjectsGetResponse, GetProjectsApiV1ProjectsGetError, GetProjectsApiV1ProjectsGetResponse, ReturnType<typeof getProjectsApiV1ProjectsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getProjectsApiV1ProjectsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectsApiV1ProjectsGetQueryKey(options)
});

/**
 * Create Project
 *
 * Create a new project.
 *
 * Requires superuser privileges.
 *
 * Args:
 * data: The project creation payload.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected project service.
 *
 * Returns:
 * The newly created :class:`~app.schemas.project.ProjectResponse`.
 *
 * Raises:
 * HTTPException: HTTP 409 if a project with the same slug already exists.
 */
export const createProjectApiV1ProjectsPostMutation = (options?: Partial<Options<CreateProjectApiV1ProjectsPostData>>): UseMutationOptions<CreateProjectApiV1ProjectsPostResponse, CreateProjectApiV1ProjectsPostError, Options<CreateProjectApiV1ProjectsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectApiV1ProjectsPostResponse, CreateProjectApiV1ProjectsPostError, Options<CreateProjectApiV1ProjectsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProjectApiV1ProjectsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey = (options?: Options<GetFeaturedProjectsApiV1ProjectsFeaturedGetData>) => createQueryKey('getFeaturedProjectsApiV1ProjectsFeaturedGet', options);

/**
 * Get Featured Projects
 *
 * Retrieve a list of featured, published projects.
 *
 * Args:
 * db: Active async database session.
 * service: Injected project service.
 *
 * Returns:
 * A list of :class:`~app.schemas.project.ProjectResponse` objects.
 */
export const getFeaturedProjectsApiV1ProjectsFeaturedGetOptions = (options?: Options<GetFeaturedProjectsApiV1ProjectsFeaturedGetData>) => queryOptions<GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, DefaultError, GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, ReturnType<typeof getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFeaturedProjectsApiV1ProjectsFeaturedGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey(options)
});

/**
 * Delete Project
 *
 * Delete a project.
 *
 * Requires superuser privileges.
 *
 * Args:
 * slug: The unique URL slug of the project to delete.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected project service.
 *
 * Raises:
 * HTTPException: HTTP 404 if the project is not found.
 */
export const deleteProjectApiV1ProjectsSlugDeleteMutation = (options?: Partial<Options<DeleteProjectApiV1ProjectsSlugDeleteData>>): UseMutationOptions<DeleteProjectApiV1ProjectsSlugDeleteResponse, DeleteProjectApiV1ProjectsSlugDeleteError, Options<DeleteProjectApiV1ProjectsSlugDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectApiV1ProjectsSlugDeleteResponse, DeleteProjectApiV1ProjectsSlugDeleteError, Options<DeleteProjectApiV1ProjectsSlugDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProjectApiV1ProjectsSlugDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectApiV1ProjectsSlugGetQueryKey = (options: Options<GetProjectApiV1ProjectsSlugGetData>) => createQueryKey('getProjectApiV1ProjectsSlugGet', options);

/**
 * Get Project
 *
 * Retrieve a single project by its slug.
 *
 * Args:
 * slug: The unique URL slug of the project.
 * db: Active async database session.
 * service: Injected project service.
 *
 * Returns:
 * The requested :class:`~app.schemas.project.ProjectResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the project is not found.
 */
export const getProjectApiV1ProjectsSlugGetOptions = (options: Options<GetProjectApiV1ProjectsSlugGetData>) => queryOptions<GetProjectApiV1ProjectsSlugGetResponse, GetProjectApiV1ProjectsSlugGetError, GetProjectApiV1ProjectsSlugGetResponse, ReturnType<typeof getProjectApiV1ProjectsSlugGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getProjectApiV1ProjectsSlugGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectApiV1ProjectsSlugGetQueryKey(options)
});

/**
 * Update Project
 *
 * Update an existing project.
 *
 * Requires superuser privileges.
 *
 * Args:
 * slug: The unique URL slug of the project to update.
 * data: The project update payload (partial).
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected project service.
 *
 * Returns:
 * The updated :class:`~app.schemas.project.ProjectResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the project is not found.
 * HTTPException: HTTP 409 if updating the slug causes a collision.
 */
export const updateProjectApiV1ProjectsSlugPatchMutation = (options?: Partial<Options<UpdateProjectApiV1ProjectsSlugPatchData>>): UseMutationOptions<UpdateProjectApiV1ProjectsSlugPatchResponse, UpdateProjectApiV1ProjectsSlugPatchError, Options<UpdateProjectApiV1ProjectsSlugPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectApiV1ProjectsSlugPatchResponse, UpdateProjectApiV1ProjectsSlugPatchError, Options<UpdateProjectApiV1ProjectsSlugPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProjectApiV1ProjectsSlugPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPostsApiV1PostsGetQueryKey = (options?: Options<GetPostsApiV1PostsGetData>) => createQueryKey('getPostsApiV1PostsGet', options);

/**
 * Get Posts
 *
 * Retrieve a list of blog posts.
 *
 * Args:
 * published_only: If ``True``, returns only published posts.
 * Defaults to ``True``.
 * db: Active async database session.
 * service: Injected post service.
 *
 * Returns:
 * A list of :class:`~app.schemas.post.PostResponse` objects ordered
 * by ``created_at`` descending (newest first).
 */
export const getPostsApiV1PostsGetOptions = (options?: Options<GetPostsApiV1PostsGetData>) => queryOptions<GetPostsApiV1PostsGetResponse, GetPostsApiV1PostsGetError, GetPostsApiV1PostsGetResponse, ReturnType<typeof getPostsApiV1PostsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPostsApiV1PostsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPostsApiV1PostsGetQueryKey(options)
});

/**
 * Create Post
 *
 * Create a new blog post.
 *
 * Requires superuser privileges.
 *
 * Args:
 * data: The post creation payload.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected post service.
 *
 * Returns:
 * The newly created :class:`~app.schemas.post.PostResponse`.
 *
 * Raises:
 * HTTPException: HTTP 409 if a post with the same slug already exists.
 */
export const createPostApiV1PostsPostMutation = (options?: Partial<Options<CreatePostApiV1PostsPostData>>): UseMutationOptions<CreatePostApiV1PostsPostResponse, CreatePostApiV1PostsPostError, Options<CreatePostApiV1PostsPostData>> => {
    const mutationOptions: UseMutationOptions<CreatePostApiV1PostsPostResponse, CreatePostApiV1PostsPostError, Options<CreatePostApiV1PostsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPostApiV1PostsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Post
 *
 * Delete a blog post.
 *
 * Requires superuser privileges.
 *
 * Args:
 * slug: The unique URL slug of the post to delete.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected post service.
 *
 * Raises:
 * HTTPException: HTTP 404 if the post is not found.
 */
export const deletePostApiV1PostsSlugDeleteMutation = (options?: Partial<Options<DeletePostApiV1PostsSlugDeleteData>>): UseMutationOptions<DeletePostApiV1PostsSlugDeleteResponse, DeletePostApiV1PostsSlugDeleteError, Options<DeletePostApiV1PostsSlugDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeletePostApiV1PostsSlugDeleteResponse, DeletePostApiV1PostsSlugDeleteError, Options<DeletePostApiV1PostsSlugDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePostApiV1PostsSlugDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPostApiV1PostsSlugGetQueryKey = (options: Options<GetPostApiV1PostsSlugGetData>) => createQueryKey('getPostApiV1PostsSlugGet', options);

/**
 * Get Post
 *
 * Retrieve a single blog post by its slug.
 *
 * Args:
 * slug: The unique URL slug of the post.
 * db: Active async database session.
 * service: Injected post service.
 *
 * Returns:
 * The requested :class:`~app.schemas.post.PostResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the post is not found.
 */
export const getPostApiV1PostsSlugGetOptions = (options: Options<GetPostApiV1PostsSlugGetData>) => queryOptions<GetPostApiV1PostsSlugGetResponse, GetPostApiV1PostsSlugGetError, GetPostApiV1PostsSlugGetResponse, ReturnType<typeof getPostApiV1PostsSlugGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPostApiV1PostsSlugGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPostApiV1PostsSlugGetQueryKey(options)
});

/**
 * Update Post
 *
 * Update an existing blog post.
 *
 * Requires superuser privileges.
 *
 * Args:
 * slug: The unique URL slug of the post to update.
 * data: The post update payload (partial).
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected post service.
 *
 * Returns:
 * The updated :class:`~app.schemas.post.PostResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the post is not found.
 */
export const updatePostApiV1PostsSlugPatchMutation = (options?: Partial<Options<UpdatePostApiV1PostsSlugPatchData>>): UseMutationOptions<UpdatePostApiV1PostsSlugPatchResponse, UpdatePostApiV1PostsSlugPatchError, Options<UpdatePostApiV1PostsSlugPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdatePostApiV1PostsSlugPatchResponse, UpdatePostApiV1PostsSlugPatchError, Options<UpdatePostApiV1PostsSlugPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePostApiV1PostsSlugPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCertificationsApiV1CertificationsGetQueryKey = (options?: Options<GetCertificationsApiV1CertificationsGetData>) => createQueryKey('getCertificationsApiV1CertificationsGet', options);

/**
 * Get Certifications
 *
 * Retrieve a list of certifications.
 *
 * Args:
 * featured_only: If ``True``, returns only featured certifications.
 * Defaults to ``False`` (return all certifications).
 * db: Active async database session.
 * service: Injected certification service.
 *
 * Returns:
 * A list of :class:`~app.schemas.certification.CertificationResponse`
 * objects ordered by ``issued_at`` descending (most recent first).
 */
export const getCertificationsApiV1CertificationsGetOptions = (options?: Options<GetCertificationsApiV1CertificationsGetData>) => queryOptions<GetCertificationsApiV1CertificationsGetResponse, GetCertificationsApiV1CertificationsGetError, GetCertificationsApiV1CertificationsGetResponse, ReturnType<typeof getCertificationsApiV1CertificationsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCertificationsApiV1CertificationsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCertificationsApiV1CertificationsGetQueryKey(options)
});

/**
 * Create Certification
 *
 * Create a new certification record.
 *
 * Requires superuser privileges.
 *
 * Args:
 * data: The certification creation payload.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected certification service.
 *
 * Returns:
 * The newly created :class:`~app.schemas.certification.CertificationResponse`.
 */
export const createCertificationApiV1CertificationsPostMutation = (options?: Partial<Options<CreateCertificationApiV1CertificationsPostData>>): UseMutationOptions<CreateCertificationApiV1CertificationsPostResponse, CreateCertificationApiV1CertificationsPostError, Options<CreateCertificationApiV1CertificationsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCertificationApiV1CertificationsPostResponse, CreateCertificationApiV1CertificationsPostError, Options<CreateCertificationApiV1CertificationsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCertificationApiV1CertificationsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Certification
 *
 * Delete a certification record.
 *
 * Requires superuser privileges.
 *
 * Args:
 * cert_id: The UUID of the certification to delete.
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected certification service.
 *
 * Raises:
 * HTTPException: HTTP 404 if the certification is not found.
 */
export const deleteCertificationApiV1CertificationsCertIdDeleteMutation = (options?: Partial<Options<DeleteCertificationApiV1CertificationsCertIdDeleteData>>): UseMutationOptions<DeleteCertificationApiV1CertificationsCertIdDeleteResponse, DeleteCertificationApiV1CertificationsCertIdDeleteError, Options<DeleteCertificationApiV1CertificationsCertIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCertificationApiV1CertificationsCertIdDeleteResponse, DeleteCertificationApiV1CertificationsCertIdDeleteError, Options<DeleteCertificationApiV1CertificationsCertIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCertificationApiV1CertificationsCertIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCertificationApiV1CertificationsCertIdGetQueryKey = (options: Options<GetCertificationApiV1CertificationsCertIdGetData>) => createQueryKey('getCertificationApiV1CertificationsCertIdGet', options);

/**
 * Get Certification
 *
 * Retrieve a single certification by its UUID.
 *
 * Args:
 * cert_id: The UUID primary key of the certification.
 * db: Active async database session.
 * service: Injected certification service.
 *
 * Returns:
 * The requested :class:`~app.schemas.certification.CertificationResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the certification is not found.
 */
export const getCertificationApiV1CertificationsCertIdGetOptions = (options: Options<GetCertificationApiV1CertificationsCertIdGetData>) => queryOptions<GetCertificationApiV1CertificationsCertIdGetResponse, GetCertificationApiV1CertificationsCertIdGetError, GetCertificationApiV1CertificationsCertIdGetResponse, ReturnType<typeof getCertificationApiV1CertificationsCertIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCertificationApiV1CertificationsCertIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCertificationApiV1CertificationsCertIdGetQueryKey(options)
});

/**
 * Update Certification
 *
 * Update an existing certification record.
 *
 * Requires superuser privileges.
 *
 * Args:
 * cert_id: The UUID of the certification to update.
 * data: The certification update payload (partial).
 * _: Superuser dependency guard.
 * db: Active async database session.
 * service: Injected certification service.
 *
 * Returns:
 * The updated :class:`~app.schemas.certification.CertificationResponse`.
 *
 * Raises:
 * HTTPException: HTTP 404 if the certification is not found.
 */
export const updateCertificationApiV1CertificationsCertIdPatchMutation = (options?: Partial<Options<UpdateCertificationApiV1CertificationsCertIdPatchData>>): UseMutationOptions<UpdateCertificationApiV1CertificationsCertIdPatchResponse, UpdateCertificationApiV1CertificationsCertIdPatchError, Options<UpdateCertificationApiV1CertificationsCertIdPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateCertificationApiV1CertificationsCertIdPatchResponse, UpdateCertificationApiV1CertificationsCertIdPatchError, Options<UpdateCertificationApiV1CertificationsCertIdPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCertificationApiV1CertificationsCertIdPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Ai Write
 */
export const aiWriteApiV1AiWritePostMutation = (options?: Partial<Options<AiWriteApiV1AiWritePostData>>): UseMutationOptions<unknown, AiWriteApiV1AiWritePostError, Options<AiWriteApiV1AiWritePostData>> => {
    const mutationOptions: UseMutationOptions<unknown, AiWriteApiV1AiWritePostError, Options<AiWriteApiV1AiWritePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await aiWriteApiV1AiWritePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Authenticate and receive a JWT access token
 *
 * Authenticate with email + password.
 *
 * On success the JWT access token is:
 *
 * 1. Set as an httpOnly cookie (``access_token``) — used by the browser frontend.
 * 2. Returned in the response body — used by API clients, tests, and the
 * OpenAPI ``/docs`` UI.
 *
 * Args:
 * data: Login credentials — ``email`` and ``password``.
 * response: FastAPI response object used to set the cookie.
 * db: Active async database session.
 * auth_service: Injected auth service.
 *
 * Returns:
 * :class:`~app.schemas.auth.TokenResponse` containing the raw JWT and
 * token type (``"bearer"``).
 *
 * Raises:
 * HTTPException: HTTP 401 when the email is not found or the password
 * is incorrect.  The error message is deliberately vague to avoid
 * leaking whether the email exists.
 * HTTPException: HTTP 403 when the account has been deactivated.
 *
 * Example::
 *
 * POST /api/v1/auth/login
 * Content-Type: application/json
 *
 * {"email": "luc@example.com", "password": "supersecret"}
 *
 * → 200 OK
 * Set-Cookie: access_token=<JWT>; HttpOnly; SameSite=Lax; Path=/
 * {"access_token": "<JWT>", "token_type": "bearer"}
 */
export const loginApiV1AuthLoginPostMutation = (options?: Partial<Options<LoginApiV1AuthLoginPostData>>): UseMutationOptions<LoginApiV1AuthLoginPostResponse, LoginApiV1AuthLoginPostError, Options<LoginApiV1AuthLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginApiV1AuthLoginPostResponse, LoginApiV1AuthLoginPostError, Options<LoginApiV1AuthLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginApiV1AuthLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const meApiV1AuthMeGetQueryKey = (options?: Options<MeApiV1AuthMeGetData>) => createQueryKey('meApiV1AuthMeGet', options);

/**
 * Return the currently authenticated user
 *
 * Return the profile of the currently authenticated user.
 *
 * This endpoint is used by the frontend on app load to determine whether a
 * valid session cookie exists and to populate the auth context.  It also
 * serves as a liveness check for the auth system.
 *
 * Args:
 * current_user: Resolved from the ``get_current_user`` dependency —
 * reads the ``access_token`` cookie or the ``Authorization`` header.
 *
 * Returns:
 * The :class:`~app.schemas.auth.UserResponse` for the authenticated user.
 * The ``hashed_password`` field is never included in this response.
 *
 * Raises:
 * HTTPException: HTTP 401 when no valid token is present.
 * HTTPException: HTTP 403 when the account is inactive.
 *
 * Example::
 *
 * GET /api/v1/auth/me
 * Cookie: access_token=<JWT>
 *
 * → 200 OK
 * {
 * "id": "...",
 * "email": "luc@example.com",
 * "is_active": true,
 * "is_superuser": true,
 * "created_at": "...",
 * "updated_at": "..."
 * }
 */
export const meApiV1AuthMeGetOptions = (options?: Options<MeApiV1AuthMeGetData>) => queryOptions<MeApiV1AuthMeGetResponse, MeApiV1AuthMeGetError, MeApiV1AuthMeGetResponse, ReturnType<typeof meApiV1AuthMeGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await meApiV1AuthMeGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: meApiV1AuthMeGetQueryKey(options)
});

/**
 * Invalidate the current session
 *
 * Log out the currently authenticated user.
 *
 * Clears the ``access_token`` httpOnly cookie so the browser stops sending
 * it on subsequent requests.
 *
 * JWT tokens are stateless — there is no server-side session to invalidate.
 * The token technically remains valid until its ``exp`` claim is reached.
 * For the portfolio's use case (single owner, long-lived sessions) this is
 * an acceptable trade-off.  If token revocation becomes a requirement,
 * introduce a Redis-backed blocklist and check it in
 * :func:`~app.core.deps.get_current_user`.
 *
 * Args:
 * response: FastAPI response object used to delete the cookie.
 * _: The authenticated user — required only to enforce that an active
 * session exists before clearing it.  The value is intentionally
 * discarded.
 *
 * Returns:
 * ``None`` — HTTP 204 No Content.
 *
 * Raises:
 * HTTPException: HTTP 401 when no valid token is present.
 *
 * Example::
 *
 * POST /api/v1/auth/logout
 * Cookie: access_token=<JWT>
 *
 * → 204 No Content
 * Set-Cookie: access_token=; Max-Age=0; Path=/
 */
export const logoutApiV1AuthLogoutPostMutation = (options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>): UseMutationOptions<LogoutApiV1AuthLogoutPostResponse, LogoutApiV1AuthLogoutPostError, Options<LogoutApiV1AuthLogoutPostData>> => {
    const mutationOptions: UseMutationOptions<LogoutApiV1AuthLogoutPostResponse, LogoutApiV1AuthLogoutPostError, Options<LogoutApiV1AuthLogoutPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logoutApiV1AuthLogoutPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const healthHealthGetQueryKey = (options?: Options<HealthHealthGetData>) => createQueryKey('healthHealthGet', options);

/**
 * Health
 */
export const healthHealthGetOptions = (options?: Options<HealthHealthGetData>) => queryOptions<HealthHealthGetResponse, DefaultError, HealthHealthGetResponse, ReturnType<typeof healthHealthGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthHealthGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthHealthGetQueryKey(options)
});
