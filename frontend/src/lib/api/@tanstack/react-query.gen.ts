// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { aiWriteApiV1AiWritePost, createProjectApiV1ProjectsPost, deleteProjectApiV1ProjectsSlugDelete, getFeaturedProjectsApiV1ProjectsFeaturedGet, getProjectApiV1ProjectsSlugGet, getProjectsApiV1ProjectsGet, healthHealthGet, loginApiV1AuthLoginPost, logoutApiV1AuthLogoutPost, meApiV1AuthMeGet, type Options, updateProjectApiV1ProjectsSlugPatch } from '../sdk.gen';
import type { AiWriteApiV1AiWritePostData, AiWriteApiV1AiWritePostError, CreateProjectApiV1ProjectsPostData, CreateProjectApiV1ProjectsPostError, CreateProjectApiV1ProjectsPostResponse, DeleteProjectApiV1ProjectsSlugDeleteData, DeleteProjectApiV1ProjectsSlugDeleteError, DeleteProjectApiV1ProjectsSlugDeleteResponse, GetFeaturedProjectsApiV1ProjectsFeaturedGetData, GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, GetProjectApiV1ProjectsSlugGetData, GetProjectApiV1ProjectsSlugGetError, GetProjectApiV1ProjectsSlugGetResponse, GetProjectsApiV1ProjectsGetData, GetProjectsApiV1ProjectsGetError, GetProjectsApiV1ProjectsGetResponse, HealthHealthGetData, HealthHealthGetResponse, LoginApiV1AuthLoginPostData, LoginApiV1AuthLoginPostError, LoginApiV1AuthLoginPostResponse, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError, LogoutApiV1AuthLogoutPostResponse, MeApiV1AuthMeGetData, MeApiV1AuthMeGetError, MeApiV1AuthMeGetResponse, UpdateProjectApiV1ProjectsSlugPatchData, UpdateProjectApiV1ProjectsSlugPatchError, UpdateProjectApiV1ProjectsSlugPatchResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getProjectsApiV1ProjectsGetQueryKey = (options?: Options<GetProjectsApiV1ProjectsGetData>) => createQueryKey('getProjectsApiV1ProjectsGet', options);

/**
 * Get Projects
 */
export const getProjectsApiV1ProjectsGetOptions = (options?: Options<GetProjectsApiV1ProjectsGetData>) => queryOptions<GetProjectsApiV1ProjectsGetResponse, GetProjectsApiV1ProjectsGetError, GetProjectsApiV1ProjectsGetResponse, ReturnType<typeof getProjectsApiV1ProjectsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getProjectsApiV1ProjectsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectsApiV1ProjectsGetQueryKey(options)
});

/**
 * Create Project
 */
export const createProjectApiV1ProjectsPostMutation = (options?: Partial<Options<CreateProjectApiV1ProjectsPostData>>): UseMutationOptions<CreateProjectApiV1ProjectsPostResponse, CreateProjectApiV1ProjectsPostError, Options<CreateProjectApiV1ProjectsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateProjectApiV1ProjectsPostResponse, CreateProjectApiV1ProjectsPostError, Options<CreateProjectApiV1ProjectsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createProjectApiV1ProjectsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey = (options?: Options<GetFeaturedProjectsApiV1ProjectsFeaturedGetData>) => createQueryKey('getFeaturedProjectsApiV1ProjectsFeaturedGet', options);

/**
 * Get Featured Projects
 */
export const getFeaturedProjectsApiV1ProjectsFeaturedGetOptions = (options?: Options<GetFeaturedProjectsApiV1ProjectsFeaturedGetData>) => queryOptions<GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, DefaultError, GetFeaturedProjectsApiV1ProjectsFeaturedGetResponse, ReturnType<typeof getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getFeaturedProjectsApiV1ProjectsFeaturedGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getFeaturedProjectsApiV1ProjectsFeaturedGetQueryKey(options)
});

/**
 * Delete Project
 */
export const deleteProjectApiV1ProjectsSlugDeleteMutation = (options?: Partial<Options<DeleteProjectApiV1ProjectsSlugDeleteData>>): UseMutationOptions<DeleteProjectApiV1ProjectsSlugDeleteResponse, DeleteProjectApiV1ProjectsSlugDeleteError, Options<DeleteProjectApiV1ProjectsSlugDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectApiV1ProjectsSlugDeleteResponse, DeleteProjectApiV1ProjectsSlugDeleteError, Options<DeleteProjectApiV1ProjectsSlugDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteProjectApiV1ProjectsSlugDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectApiV1ProjectsSlugGetQueryKey = (options: Options<GetProjectApiV1ProjectsSlugGetData>) => createQueryKey('getProjectApiV1ProjectsSlugGet', options);

/**
 * Get Project
 */
export const getProjectApiV1ProjectsSlugGetOptions = (options: Options<GetProjectApiV1ProjectsSlugGetData>) => queryOptions<GetProjectApiV1ProjectsSlugGetResponse, GetProjectApiV1ProjectsSlugGetError, GetProjectApiV1ProjectsSlugGetResponse, ReturnType<typeof getProjectApiV1ProjectsSlugGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getProjectApiV1ProjectsSlugGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getProjectApiV1ProjectsSlugGetQueryKey(options)
});

/**
 * Update Project
 */
export const updateProjectApiV1ProjectsSlugPatchMutation = (options?: Partial<Options<UpdateProjectApiV1ProjectsSlugPatchData>>): UseMutationOptions<UpdateProjectApiV1ProjectsSlugPatchResponse, UpdateProjectApiV1ProjectsSlugPatchError, Options<UpdateProjectApiV1ProjectsSlugPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateProjectApiV1ProjectsSlugPatchResponse, UpdateProjectApiV1ProjectsSlugPatchError, Options<UpdateProjectApiV1ProjectsSlugPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateProjectApiV1ProjectsSlugPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Ai Write
 */
export const aiWriteApiV1AiWritePostMutation = (options?: Partial<Options<AiWriteApiV1AiWritePostData>>): UseMutationOptions<unknown, AiWriteApiV1AiWritePostError, Options<AiWriteApiV1AiWritePostData>> => {
    const mutationOptions: UseMutationOptions<unknown, AiWriteApiV1AiWritePostError, Options<AiWriteApiV1AiWritePostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await aiWriteApiV1AiWritePost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Authenticate and receive a JWT access token
 *
 * Authenticate with email + password.
 *
 * On success the JWT access token is:
 *
 * 1. Set as an httpOnly cookie (``access_token``) — used by the browser frontend.
 * 2. Returned in the response body — used by API clients, tests, and the
 * OpenAPI ``/docs`` UI.
 *
 * Args:
 * data: Login credentials — ``email`` and ``password``.
 * response: FastAPI response object used to set the cookie.
 * db: Active async database session.
 * auth_service: Injected auth service.
 *
 * Returns:
 * :class:`~app.schemas.auth.TokenResponse` containing the raw JWT and
 * token type (``"bearer"``).
 *
 * Raises:
 * HTTPException: HTTP 401 when the email is not found or the password
 * is incorrect.  The error message is deliberately vague to avoid
 * leaking whether the email exists.
 * HTTPException: HTTP 403 when the account has been deactivated.
 *
 * Example::
 *
 * POST /api/v1/auth/login
 * Content-Type: application/json
 *
 * {"email": "luc@example.com", "password": "supersecret"}
 *
 * → 200 OK
 * Set-Cookie: access_token=<JWT>; HttpOnly; SameSite=Lax; Path=/
 * {"access_token": "<JWT>", "token_type": "bearer"}
 */
export const loginApiV1AuthLoginPostMutation = (options?: Partial<Options<LoginApiV1AuthLoginPostData>>): UseMutationOptions<LoginApiV1AuthLoginPostResponse, LoginApiV1AuthLoginPostError, Options<LoginApiV1AuthLoginPostData>> => {
    const mutationOptions: UseMutationOptions<LoginApiV1AuthLoginPostResponse, LoginApiV1AuthLoginPostError, Options<LoginApiV1AuthLoginPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await loginApiV1AuthLoginPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const meApiV1AuthMeGetQueryKey = (options?: Options<MeApiV1AuthMeGetData>) => createQueryKey('meApiV1AuthMeGet', options);

/**
 * Return the currently authenticated user
 *
 * Return the profile of the currently authenticated user.
 *
 * This endpoint is used by the frontend on app load to determine whether a
 * valid session cookie exists and to populate the auth context.  It also
 * serves as a liveness check for the auth system.
 *
 * Args:
 * current_user: Resolved from the ``get_current_user`` dependency —
 * reads the ``access_token`` cookie or the ``Authorization`` header.
 *
 * Returns:
 * The :class:`~app.schemas.auth.UserResponse` for the authenticated user.
 * The ``hashed_password`` field is never included in this response.
 *
 * Raises:
 * HTTPException: HTTP 401 when no valid token is present.
 * HTTPException: HTTP 403 when the account is inactive.
 *
 * Example::
 *
 * GET /api/v1/auth/me
 * Cookie: access_token=<JWT>
 *
 * → 200 OK
 * {
 * "id": "...",
 * "email": "luc@example.com",
 * "is_active": true,
 * "is_superuser": true,
 * "created_at": "...",
 * "updated_at": "..."
 * }
 */
export const meApiV1AuthMeGetOptions = (options?: Options<MeApiV1AuthMeGetData>) => queryOptions<MeApiV1AuthMeGetResponse, MeApiV1AuthMeGetError, MeApiV1AuthMeGetResponse, ReturnType<typeof meApiV1AuthMeGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await meApiV1AuthMeGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: meApiV1AuthMeGetQueryKey(options)
});

/**
 * Invalidate the current session
 *
 * Log out the currently authenticated user.
 *
 * Clears the ``access_token`` httpOnly cookie so the browser stops sending
 * it on subsequent requests.
 *
 * JWT tokens are stateless — there is no server-side session to invalidate.
 * The token technically remains valid until its ``exp`` claim is reached.
 * For the portfolio's use case (single owner, long-lived sessions) this is
 * an acceptable trade-off.  If token revocation becomes a requirement,
 * introduce a Redis-backed blocklist and check it in
 * :func:`~app.core.deps.get_current_user`.
 *
 * Args:
 * response: FastAPI response object used to delete the cookie.
 * _: The authenticated user — required only to enforce that an active
 * session exists before clearing it.  The value is intentionally
 * discarded.
 *
 * Returns:
 * ``None`` — HTTP 204 No Content.
 *
 * Raises:
 * HTTPException: HTTP 401 when no valid token is present.
 *
 * Example::
 *
 * POST /api/v1/auth/logout
 * Cookie: access_token=<JWT>
 *
 * → 204 No Content
 * Set-Cookie: access_token=; Max-Age=0; Path=/
 */
export const logoutApiV1AuthLogoutPostMutation = (options?: Partial<Options<LogoutApiV1AuthLogoutPostData>>): UseMutationOptions<LogoutApiV1AuthLogoutPostResponse, LogoutApiV1AuthLogoutPostError, Options<LogoutApiV1AuthLogoutPostData>> => {
    const mutationOptions: UseMutationOptions<LogoutApiV1AuthLogoutPostResponse, LogoutApiV1AuthLogoutPostError, Options<LogoutApiV1AuthLogoutPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logoutApiV1AuthLogoutPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const healthHealthGetQueryKey = (options?: Options<HealthHealthGetData>) => createQueryKey('healthHealthGet', options);

/**
 * Health
 */
export const healthHealthGetOptions = (options?: Options<HealthHealthGetData>) => queryOptions<HealthHealthGetResponse, DefaultError, HealthHealthGetResponse, ReturnType<typeof healthHealthGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthHealthGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthHealthGetQueryKey(options)
});
