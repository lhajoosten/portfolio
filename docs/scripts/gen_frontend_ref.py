"""Auto-generate frontend API reference pages for MkDocs.

This script is executed by the ``mkdocs-gen-files`` plugin during the MkDocs
build.  It works in two phases:

1. **TypeDoc phase** — runs ``pnpm typedoc`` (if not already run) to produce
   Markdown output into ``frontend/typedoc-out/``.

2. **Injection phase** — walks the TypeDoc Markdown output and copies each
   file into the MkDocs ``docs/frontend/`` virtual tree so that
   ``mkdocstrings``-style cross-links and the Material theme render them
   correctly.

The script is intentionally forgiving: if TypeDoc has not been installed or
the frontend directory does not exist, it emits a placeholder page rather
than failing the entire docs build.  This lets ``mkdocs serve`` work even
on machines that have only the Python toolchain installed.

Run indirectly via::

    mkdocs build   # or: mkdocs serve

Run TypeDoc standalone::

    cd frontend && pnpm typedoc
"""

from __future__ import annotations

import subprocess
import sys
from pathlib import Path

import mkdocs_gen_files

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------

DOCS_ROOT = Path(__file__).parent.parent  # portfolio/docs/
REPO_ROOT = DOCS_ROOT.parent  # portfolio/
FRONTEND_DIR = REPO_ROOT / "frontend"
TYPEDOC_OUT = FRONTEND_DIR / "typedoc-out"  # TypeDoc --out target
OUTPUT_PREFIX = "frontend"  # MkDocs output section

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _run_typedoc() -> bool:
    """Attempt to run ``pnpm typedoc`` in the frontend directory.

    Returns:
        ``True`` if TypeDoc ran successfully, ``False`` otherwise.
    """
    if not (FRONTEND_DIR / "package.json").exists():
        return False

    try:
        result = subprocess.run(  # noqa: S603
            ["pnpm", "typedoc"],
            cwd=FRONTEND_DIR,
            capture_output=True,
            text=True,
            timeout=120,
        )
        if result.returncode != 0:
            print(  # noqa: T201
                f"[gen_frontend_ref] TypeDoc exited with code {result.returncode}:\n"
                f"{result.stderr}",
                file=sys.stderr,
            )
            return False
        return True
    except (FileNotFoundError, subprocess.TimeoutExpired) as exc:
        print(  # noqa: T201
            f"[gen_frontend_ref] Could not run TypeDoc: {exc}",
            file=sys.stderr,
        )
        return False


def _write_placeholder() -> None:
    """Emit a placeholder page when TypeDoc output is unavailable."""
    placeholder = Path(OUTPUT_PREFIX) / "index.md"
    with mkdocs_gen_files.open(placeholder, "w") as f:
        f.write("# Frontend Reference\n\n")
        f.write(
            '!!! warning "TypeDoc output not found"\n\n'
            "    Frontend reference pages are generated by TypeDoc.\n"
            "    Run the following to generate them:\n\n"
            "    ```bash\n"
            "    task docs:typedoc\n"
            "    # or directly:\n"
            "    cd frontend && pnpm typedoc\n"
            "    ```\n\n"
            "    Then rebuild the docs:\n\n"
            "    ```bash\n"
            "    task docs:build\n"
            "    ```\n"
        )


def _inject_typedoc_pages() -> None:
    """Copy TypeDoc Markdown files into the MkDocs virtual docs tree.

    Each ``.md`` file under ``frontend/typedoc-out/`` is reproduced under
    ``docs/frontend/`` with the same relative path.  The TypeDoc index page
    (``README.md``) is mapped to ``frontend/index.md``.
    """
    nav = mkdocs_gen_files.Nav()

    md_files: list[Path] = sorted(TYPEDOC_OUT.rglob("*.md"))

    if not md_files:
        _write_placeholder()
        return

    for md_file in md_files:
        relative = md_file.relative_to(TYPEDOC_OUT)

        # TypeDoc uses README.md as the section index
        if relative.name == "README.md":
            out_path = Path(OUTPUT_PREFIX) / relative.parent / "index.md"
        else:
            out_path = Path(OUTPUT_PREFIX) / relative

        # Build nav entry from path components
        parts = list(relative.with_suffix("").parts)
        if parts and parts[-1] == "README":
            parts[-1] = "index"
        nav_parts = [p.replace("-", " ").replace("_", " ").title() for p in parts]

        if nav_parts:
            nav[nav_parts] = out_path.as_posix()

        content = md_file.read_text(encoding="utf-8")
        content = _patch_typedoc_markdown(content)

        with mkdocs_gen_files.open(out_path, "w") as f:
            f.write(content)

        mkdocs_gen_files.set_edit_path(
            out_path,
            md_file.relative_to(REPO_ROOT),
        )

    # Write SUMMARY.md for mkdocs-literate-nav
    with mkdocs_gen_files.open(f"{OUTPUT_PREFIX}/SUMMARY.md", "w") as nav_file:
        nav_file.writelines(nav.build_literate_nav())


def _patch_typedoc_markdown(content: str) -> str:
    """Apply post-processing patches to TypeDoc-generated Markdown.

    TypeDoc targets GitHub Markdown flavour.  This function adjusts output
    to work better with MkDocs Material:

    - Strips the ``Defined in`` footer lines (source links break in MkDocs).
    - Replaces TypeDoc's ``##`` heading anchors with plain headings.
    - Normalises ``README.md`` cross-links to ``index.md`` so that
      MkDocs resolves them correctly.

    Args:
        content: Raw Markdown string from TypeDoc.

    Returns:
        Patched Markdown string.
    """
    import re

    # Fix README.md -> index.md internal links
    content = re.sub(r"\bREADME\.md\b", "index.md", content)

    # Remove "Defined in: path/to/file.ts:LINE" lines emitted by TypeDoc
    content = re.sub(r"\n+Defined in:.*\n", "\n", content)

    # TypeDoc wraps type signatures in code blocks with no language hint.
    # Add "typescript" for syntax highlighting.
    content = re.sub(r"```\n((?:[^\n`].*\n)+?)```", r"```typescript\n\1```", content)

    return content


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def generate() -> None:
    """Entry point called by mkdocs-gen-files during the MkDocs build."""

    # Re-use existing TypeDoc output if already present.
    # This avoids re-running pnpm on every mkdocs hot-reload.
    if not TYPEDOC_OUT.exists() or not any(TYPEDOC_OUT.rglob("*.md")):
        print(  # noqa: T201
            "[gen_frontend_ref] TypeDoc output not found — attempting to run TypeDoc...",
        )
        success = _run_typedoc()
        if not success:
            print(  # noqa: T201
                "[gen_frontend_ref] TypeDoc unavailable — writing placeholder page.",
            )
            _write_placeholder()
            return

    _inject_typedoc_pages()


if __name__ == "__main__":
    sys.exit(generate() or 0)  # type: ignore[func-returns-value]


generate()
